<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Point & Click Adventure - Proof of Concept</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #game-container { touch-action: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <script>
        // ============================================================================
        // BASE SCENE - Contains all shared functionality
        // Individual room scenes extend this and only define room-specific content
        // ============================================================================
        class BaseScene extends Phaser.Scene {
            constructor(config) {
                super(config);

                // Scene configuration (override in subclasses)
                this.worldWidth = 1280;
                this.screenWidth = 1280;
                this.screenHeight = 720;
                this.walkableArea = { minY: 0.62, maxY: 0.88 };

                // Player state
                this.player = null;
                this.isWalking = false;
                this.walkTween = null;
                this.bobTween = null;
                this.leftLeg = null;
                this.rightLeg = null;

                // Movement
                this.lastClickTime = 0;
                this.doubleClickThreshold = 300;
                this.isRunningHold = false;
                this.runningHoldStartTime = 0;
                this.interactionRange = 80;

                // Verb coin system
                this.verbCoinDelay = 200;
                this.pressTimer = null;
                this.pressedHotspot = null;
                this.verbCoinVisible = false;
                this.pointerDownPos = null;
                this.verbCoin = null;
                this.verbCoinActions = [];
                this.activeHotspot = null;
                this.hoveredAction = null;
                this.isHoldingOnHotspot = false;

                // Verb coin sizes (set in create based on device)
                this.isMobile = false;
                this.verbCoinRadius = 100;
                this.verbActionRadius = 32;
                this.verbActionHoverRadius = 38;
                this.verbCoinScale = 1;

                // Inventory verb coin
                this.pressedInventoryItem = null;
                this.pressedInventorySlot = null;
                this.inventoryItemPressTimer = null;
                this.activeInventoryItem = null;

                // Inventory UI
                this.inventoryPanel = null;
                this.inventoryOpen = false;
                this.inventorySlots = [];
                this.selectedSlotHighlight = null;
                this.itemOutsideInventoryTimer = null;
                this.itemCursor = null;

                // Cursor
                this.crosshairCursor = null;
                this.crosshairGraphics = null;
                this.arrowCursor = null;
                this.arrowGraphics = null;
                this.arrowDirection = null;
                this.hotspotLabel = null;
                this.currentHoveredHotspot = null;

                // Dialogue
                this.speechBubble = null;
                this.dialogText = null;
                this.dialogTimer = null;
                this.dialogQueue = [];
                this.dialogCallback = null;
                this.dialogActive = false;
                this.dialogSkipReady = false;

                // Conversation mode (dialogue trees with NPCs)
                this.conversationActive = false;
                this.conversationNPC = null;
                this.conversationData = null;
                this.conversationState = null;
                this.dialogueOptionsUI = null;
                this.dialogueOptionTexts = [];
                this.npcSpeechBubble = null;
                this.npcDialogText = null;
                this.awaitingNPCResponse = false;
                this.justClickedDialogueOption = false;
                this.conversationLineTimer = null;
                this.conversationLineCallback = null;
                this.conversationLineSpeaker = null;

                // Hotspots
                this.hotspots = [];
                this.itemCursorHighlight = null;

                // UI tracking
                this.clickedUI = false;
            }

            // ========== GAME STATE MANAGEMENT ==========

            getGameState() {
                let state = this.registry.get('gameState');
                if (!state) {
                    // Initialize default state ONCE and save it
                    console.log('[GameState] Initializing fresh state (first time)');
                    state = {
                        inventory: [],
                        selectedItem: null,
                        flags: {},
                        visitedRooms: []
                    };
                    this.registry.set('gameState', state);
                }
                return state;
            }

            setGameState(state) {
                this.registry.set('gameState', state);
            }

            getFlag(flagName) {
                const state = this.getGameState();
                return state.flags[flagName] || false;
            }

            setFlag(flagName, value = true) {
                const state = this.getGameState();
                state.flags[flagName] = value;
                this.setGameState(state);
            }

            // ========== SCENE LIFECYCLE ==========

            create() {
                const { width, height } = this.scale;

                // Reset scene-specific state (constructor doesn't re-run on scene.start())
                this.inventorySlots = [];
                this.hotspots = [];
                this.verbCoinVisible = false;
                this.inventoryOpen = false;
                this.dialogActive = false;
                this.dialogQueue = [];
                this.isWalking = false;

                // Detect mobile/touch device and set verb coin sizes
                this.isMobile = this.sys.game.device.input.touch;
                if (this.isMobile) {
                    this.verbCoinRadius = 200;
                    this.verbActionRadius = 64;
                    this.verbActionHoverRadius = 76;
                    this.verbCoinScale = 2;
                } else {
                    this.verbCoinRadius = 100;
                    this.verbActionRadius = 32;
                    this.verbActionHoverRadius = 38;
                    this.verbCoinScale = 1;
                }

                // Create pixel texture for player if needed
                if (!this.textures.exists('pixel')) {
                    const g = this.make.graphics({ add: false });
                    g.fillStyle(0xbbbbbb);
                    g.fillRect(0, 0, 6, 6);
                    g.generateTexture('pixel', 6, 6);
                    g.destroy();
                }

                // Hide browser cursor
                this.game.canvas.style.cursor = 'none';

                // Setup input handlers
                this.setupInputHandlers();

                // Create UI systems
                this.createCrosshairCursor(width, height);
                this.createVerbCoin(width, height);
                this.createInventoryUI(width, height);
                this.createItemCursor();
                this.createDialogUI(width, height);
                this.createConversationUI(width, height);

                // Restore inventory from game state
                this.rebuildInventoryFromState();

                // Fade in
                this.cameras.main.fadeIn(500, 0, 0, 0);
            }

            rebuildInventoryFromState() {
                const state = this.getGameState();

                console.log('[' + this.scene.key + '] Rebuilding inventory from state:', {
                    inventory: state.inventory ? state.inventory.map(i => i.id) : [],
                    flags: state.flags,
                    selectedItem: state.selectedItem ? state.selectedItem.id : null,
                    slotsAvailable: this.inventorySlots.length
                });

                if (!state.inventory || state.inventory.length === 0) {
                    console.log('[' + this.scene.key + '] No items in inventory to restore');
                    return;
                }

                // Re-add each item to inventory UI (slots are fresh, so just add to UI)
                state.inventory.forEach(item => {
                    // Check if slot already has this item (shouldn't happen but be safe)
                    const existingSlot = this.inventorySlots.find(s => s.item && s.item.id === item.id);
                    if (!existingSlot) {
                        console.log('[' + this.scene.key + '] Adding item to slot:', item.id);
                        this.addItemToSlot(item);
                    } else {
                        console.log('[' + this.scene.key + '] Item already in slot:', item.id);
                    }
                });

                // Restore selected item cursor
                if (state.selectedItem) {
                    const slot = this.inventorySlots.find(s => s.item && s.item.id === state.selectedItem.id);
                    if (slot) {
                        this.selectItem(state.selectedItem, slot);
                    }
                }
            }

            // ========== INPUT HANDLERS ==========

            setupInputHandlers() {
                // Left click
                this.input.on('pointerdown', (pointer) => {
                    if (pointer.leftButtonDown()) {
                        // Check mobile inventory button first (uses screen coords, ignores camera scroll)
                        if (this.isClickOnInventoryButton(pointer)) {
                            this.clickedUI = true;
                            this.toggleInventory();
                            return;
                        }
                        if (this.dialogActive) {
                            this.skipToNextDialog();
                            return;
                        }
                        if (this.conversationActive) {
                            // Allow clicking to skip conversation dialogue
                            // But not if we just clicked a dialogue option (that would skip the hero's line)
                            if (this.conversationLineCallback && !this.justClickedDialogueOption) {
                                this.skipConversationLine();
                            }
                            return;
                        }
                        this.handleBackgroundPress(pointer);
                    }
                    if (pointer.rightButtonDown()) {
                        if (this.conversationActive) return;
                        if (this.verbCoinVisible) {
                            this.hideVerbCoin();
                            return;
                        }
                        if (this.getGameState().selectedItem) {
                            this.deselectItem();
                            return;
                        }
                        this.toggleInventory();
                    }
                });

                this.input.on('pointerup', (pointer) => {
                    this.handlePointerUp(pointer);
                });

                this.input.on('pointermove', (pointer) => {
                    this.updateVerbCoinHover(pointer);
                    if (this.inventoryOpen && this.getGameState().selectedItem) {
                        this.checkItemOutsideInventory(pointer);
                    }
                });

                // Period key for dialogue skip
                this.input.keyboard.on('keydown-PERIOD', () => {
                    if (this.dialogActive) this.skipToNextDialog();
                    if (this.conversationActive && this.conversationLineCallback) {
                        this.skipConversationLine();
                    }
                });

                // Prevent context menu
                this.game.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            // Check if pointer is on the mobile inventory button (screen coordinates)
            isClickOnInventoryButton(pointer) {
                if (!this.inventoryButtonArea) return false;
                const btn = this.inventoryButtonArea;
                return pointer.x >= btn.x - btn.size/2 && pointer.x <= btn.x + btn.size/2 &&
                       pointer.y >= btn.y - btn.size/2 && pointer.y <= btn.y + btn.size/2;
            }

            handleBackgroundPress(pointer) {
                if (this.clickedUI) return;

                if (this.verbCoinVisible) {
                    this.hideVerbCoin();
                    return;
                }

                if (this.inventoryOpen) {
                    const { width, height } = this.scale;
                    const panelWidth = width - 100;
                    const panelHeight = height - 120;
                    const panelLeft = (width - panelWidth) / 2;
                    const panelRight = panelLeft + panelWidth;
                    const panelTop = (height - panelHeight) / 2;
                    const panelBottom = panelTop + panelHeight;

                    if (pointer.x < panelLeft || pointer.x > panelRight ||
                        pointer.y < panelTop || pointer.y > panelBottom) {
                        this.toggleInventory();
                    }
                    return;
                }

                if (this.getGameState().selectedItem) {
                    this.deselectItem();
                    return;
                }

                // Double-click to run
                const currentTime = Date.now();
                const isDoubleClick = (currentTime - this.lastClickTime) < this.doubleClickThreshold;
                this.lastClickTime = currentTime;

                if (isDoubleClick) {
                    this.isRunningHold = true;
                    this.runningHoldStartTime = Date.now();
                    this.runToPointer(pointer);
                    return;
                }

                this.pointerDownPos = { x: pointer.x, y: pointer.y };
                this.isHoldingOnHotspot = false;
            }

            handlePointerUp(pointer) {
                // Clear running hold
                if (this.isRunningHold) {
                    const wasHolding = (Date.now() - this.runningHoldStartTime) > 150;
                    this.isRunningHold = false;
                    if (wasHolding) {
                        this.isWalking = false;
                        this.stopWalkAnimation();
                    }
                }

                // Cancel timers
                if (this.pressTimer) {
                    this.pressTimer.remove();
                    this.pressTimer = null;
                }
                if (this.inventoryItemPressTimer) {
                    this.inventoryItemPressTimer.remove();
                    this.inventoryItemPressTimer = null;
                }

                // Handle inventory item verb coin
                if (this.verbCoinVisible && this.activeInventoryItem) {
                    const action = this.hoveredAction;
                    const item = this.activeInventoryItem;
                    this.hideVerbCoin();
                    if (action) this.performInventoryItemAction(action, item);
                    this.pressedInventoryItem = null;
                    this.pressedInventorySlot = null;
                    this.clickedUI = false;
                    return;
                }

                if (this.clickedUI) {
                    this.clickedUI = false;
                    this.pressedHotspot = null;
                    this.verbCoinVisible = false;
                    this.isHoldingOnHotspot = false;
                    this.pointerDownPos = null;
                    return;
                }

                // Don't handle normal interactions during conversation
                if (this.conversationActive) {
                    this.pressedHotspot = null;
                    this.isHoldingOnHotspot = false;
                    this.pointerDownPos = null;
                    return;
                }

                // Handle hotspot verb coin
                if (this.verbCoinVisible && this.hoveredAction && this.activeHotspot) {
                    const action = this.hoveredAction;
                    const hotspot = this.activeHotspot;
                    this.hideVerbCoin();
                    if (!this.isPlayerNearHotspot(hotspot)) {
                        this.walkTo(hotspot.interactX, hotspot.interactY, () => {
                            this.executeAction(action, hotspot);
                        });
                    } else {
                        this.executeAction(action, hotspot);
                    }
                } else if (this.verbCoinVisible) {
                    this.hideVerbCoin();
                } else if (this.isHoldingOnHotspot && this.pressedHotspot) {
                    this.walkTo(this.pressedHotspot.interactX, this.pressedHotspot.interactY);
                } else if (!this.isHoldingOnHotspot && this.pointerDownPos) {
                    this.handleBackgroundClick(this.pointerDownPos.x, this.pointerDownPos.y);
                }

                this.pressedHotspot = null;
                this.isHoldingOnHotspot = false;
                this.pointerDownPos = null;
            }

            handleBackgroundClick(x, y) {
                if (this.dialogActive || this.conversationActive) return;

                const { height } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;

                const worldX = x + scrollX;
                const worldY = y + scrollY;

                const minY = height * this.walkableArea.minY;
                const maxY = height * this.walkableArea.maxY;
                const targetY = Phaser.Math.Clamp(worldY, minY, maxY);

                if (this.isRunningHold) return;

                this.walkTo(worldX, targetY, null, false);
            }

            runToPointer(pointer) {
                const { height } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;

                const worldX = pointer.x + scrollX;
                const worldY = pointer.y + scrollY;

                const minY = height * this.walkableArea.minY;
                const maxY = height * this.walkableArea.maxY;
                const targetY = Phaser.Math.Clamp(worldY, minY, maxY);

                this.walkTo(worldX, targetY, null, true);
            }

            handleHotspotPress(hotspot, pointer) {
                if (!pointer.leftButtonDown()) return;
                if (this.isRunningHold) return;
                if (this.conversationActive) return;

                if (this.verbCoinVisible) {
                    this.hideVerbCoin();
                    return;
                }

                const selectedItem = this.getGameState().selectedItem;
                if (selectedItem) {
                    this.clickedUI = true;
                    if (this.isPlayerNearHotspot(hotspot)) {
                        this.useItemOnHotspot(selectedItem, hotspot);
                    } else {
                        this.walkTo(hotspot.interactX, hotspot.interactY, () => {
                            this.useItemOnHotspot(selectedItem, hotspot);
                        });
                    }
                    return;
                }

                this.isHoldingOnHotspot = true;
                this.pressedHotspot = hotspot;

                this.pressTimer = this.time.delayedCall(this.verbCoinDelay, () => {
                    this.showVerbCoin(hotspot, pointer.x, pointer.y);
                });
            }

            // ========== PLAYER ==========

            createPlayer(spawnX, spawnY) {
                const { height } = this.scale;
                const playerY = spawnY || height * 0.75;

                this.player = this.add.container(spawnX, playerY);

                const p = 6; // Pixel size
                const pixel = (x, y, color) => {
                    const sprite = this.add.sprite(x * p, -y * p, 'pixel');
                    sprite.setTint(color);
                    sprite.setPipeline('Light2D');
                    return sprite;
                };

                // Colors
                const SKIN = 0xeabc8e, SKIN_DARK = 0xd4a574;
                const HAIR = 0x2ecc71, HAIR_DARK = 0x1fa855;
                const VEST = 0x3366aa, VEST_DARK = 0x254a7a;
                const SHIRT = 0xeeeeee, SHIRT_DARK = 0xcccccc;
                const PANTS = 0x2c3e50, PANTS_DARK = 0x1a252f;
                const SHOES = 0x1a1a1a, BLACK = 0x000000, WHITE = 0xffffff;

                const pixels = [];

                // Shoes
                for (let x = -5; x <= -2; x++) { pixels.push(pixel(x, 0, SHOES)); pixels.push(pixel(x, 1, SHOES)); }
                for (let x = 2; x <= 5; x++) { pixels.push(pixel(x, 0, SHOES)); pixels.push(pixel(x, 1, SHOES)); }

                // Legs
                this.leftLegPixels = [];
                this.rightLegPixels = [];
                for (let y = 2; y <= 18; y++) {
                    for (let x = -4; x <= -2; x++) this.leftLegPixels.push(pixel(x, y, x === -4 ? PANTS_DARK : PANTS));
                    for (let x = 2; x <= 4; x++) this.rightLegPixels.push(pixel(x, y, x === 4 ? PANTS_DARK : PANTS));
                }
                this.leftLeg = this.add.container(0, 0, this.leftLegPixels);
                this.rightLeg = this.add.container(0, 0, this.rightLegPixels);

                // Torso
                for (let y = 19; y <= 28; y++) {
                    pixels.push(pixel(-6, y, SHIRT)); pixels.push(pixel(-5, y, SHIRT_DARK));
                    pixels.push(pixel(5, y, SHIRT_DARK)); pixels.push(pixel(6, y, SHIRT));
                }
                for (let y = 18; y <= 30; y++) {
                    for (let x = -4; x <= 4; x++) {
                        if (x === -4 || x === 4) pixels.push(pixel(x, y, VEST_DARK));
                        else if (x === 0 && y >= 20) pixels.push(pixel(x, y, SHIRT));
                        else pixels.push(pixel(x, y, VEST));
                    }
                }
                for (let x = -3; x <= 3; x++) pixels.push(pixel(x, 31, VEST));
                pixels.push(pixel(-2, 32, VEST)); pixels.push(pixel(2, 32, VEST));

                // Hands
                for (let y = 19; y <= 21; y++) {
                    pixels.push(pixel(-6, y, SKIN)); pixels.push(pixel(-7, y, SKIN_DARK));
                    pixels.push(pixel(6, y, SKIN)); pixels.push(pixel(7, y, SKIN_DARK));
                }

                // Neck & Head
                for (let i = 0; i < 2; i++) for (let x = -1; x <= 1; x++) pixels.push(pixel(x, 32 + i, SKIN));
                for (let y = 34; y <= 42; y++) {
                    let w = y >= 37 && y <= 39 ? 5 : (y >= 36 && y <= 40 ? 4 : 3);
                    for (let x = -w; x <= w; x++) pixels.push(pixel(x, y, (x === -w || x === w) ? SKIN_DARK : SKIN));
                }

                // Eyes
                [-3, -2].forEach(x => { pixels.push(pixel(x, 38, BLACK)); pixels.push(pixel(x, 39, BLACK)); });
                [2, 3].forEach(x => { pixels.push(pixel(x, 38, BLACK)); pixels.push(pixel(x, 39, BLACK)); });
                pixels.push(pixel(-3, 39, WHITE)); pixels.push(pixel(2, 39, WHITE));
                for (let x = -4; x <= 4; x++) if (x !== 0) pixels.push(pixel(x, 40, BLACK));
                [-1, 0, 1].forEach(x => pixels.push(pixel(x, 36, SKIN_DARK)));

                // Hair
                for (let y = 41; y <= 45; y++) {
                    let w = y >= 44 ? 4 : (y >= 43 ? 5 : 4);
                    if (y >= 45) w = 3;
                    for (let x = -w; x <= w; x++) pixels.push(pixel(x, y, (x === -w || x === w || y === 45) ? HAIR_DARK : HAIR));
                }
                pixels.push(pixel(-3, 46, HAIR)); pixels.push(pixel(-2, 46, HAIR)); pixels.push(pixel(-2, 47, HAIR_DARK));
                pixels.push(pixel(0, 46, HAIR)); pixels.push(pixel(0, 47, HAIR)); pixels.push(pixel(0, 48, HAIR_DARK));
                pixels.push(pixel(2, 46, HAIR)); pixels.push(pixel(3, 46, HAIR)); pixels.push(pixel(2, 47, HAIR_DARK));
                for (let y = 38; y <= 41; y++) { pixels.push(pixel(-5, y, HAIR_DARK)); pixels.push(pixel(5, y, HAIR_DARK)); }

                this.player.add([this.leftLeg, this.rightLeg, ...pixels]);
                this.player.setDepth(100);
            }

            // ========== WALKING ==========

            walkTo(targetX, targetY, onComplete = null, isRunning = false) {
                if (this.dialogActive || this.conversationActive) return;

                const { height } = this.scale;
                targetX = Phaser.Math.Clamp(targetX, 30, this.worldWidth - 30);
                targetY = Phaser.Math.Clamp(targetY, height * this.walkableArea.minY, height * this.walkableArea.maxY);

                if (this.walkTween) this.walkTween.stop();
                if (this.bobTween) this.bobTween.stop();

                const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, targetX, targetY);
                if (distance < 5) {
                    if (onComplete) onComplete();
                    return;
                }

                if (targetX < this.player.x) this.player.setScale(-1, 1);
                else if (targetX > this.player.x) this.player.setScale(1, 1);

                this.isWalking = true;
                this.startWalkAnimation(isRunning);

                const speed = isRunning ? 500 : 300;
                const duration = (distance / speed) * 1000;

                this.walkTween = this.tweens.add({
                    targets: this.player,
                    x: targetX,
                    y: targetY,
                    duration: duration,
                    ease: 'Linear',
                    onUpdate: () => {
                        this.player.setDepth(100 + this.player.y);
                        // Camera follow for wide rooms
                        if (this.worldWidth > this.screenWidth) {
                            this.cameras.main.scrollX = Phaser.Math.Clamp(
                                this.player.x - this.screenWidth / 2,
                                0,
                                this.worldWidth - this.screenWidth
                            );
                        }
                    },
                    onComplete: () => {
                        this.isWalking = false;
                        this.stopWalkAnimation();
                        if (onComplete) onComplete();
                    }
                });
            }

            startWalkAnimation(isRunning = false) {
                const animDuration = isRunning ? 100 : 200;
                const legSwing = isRunning ? 8 : 5;

                this.bobTween = this.tweens.add({
                    targets: { progress: 0 },
                    progress: 1,
                    duration: animDuration,
                    repeat: -1,
                    yoyo: true,
                    onUpdate: (tween) => {
                        const progress = tween.getValue();
                        if (this.leftLeg) this.leftLeg.x = Math.sin(progress * Math.PI) * legSwing;
                        if (this.rightLeg) this.rightLeg.x = -Math.sin(progress * Math.PI) * legSwing;
                    }
                });
            }

            stopWalkAnimation() {
                if (this.bobTween) this.bobTween.stop();
                if (this.leftLeg) this.leftLeg.x = 0;
                if (this.rightLeg) this.rightLeg.x = 0;
            }

            // Stop character movement when UI opens (verb coin, inventory)
            stopCharacterMovement() {
                if (this.walkTween) {
                    this.walkTween.stop();
                    this.walkTween = null;
                }
                this.isWalking = false;
                this.stopWalkAnimation();
            }

            isPlayerNearHotspot(hotspot) {
                const dist = Phaser.Math.Distance.Between(
                    this.player.x, this.player.y,
                    hotspot.interactX, hotspot.interactY
                );
                return dist < this.interactionRange;
            }

            // ========== HOTSPOTS ==========

            createHotspots(hotspotData) {
                this.hotspots = [];

                hotspotData.forEach(spot => {
                    const zone = this.add.zone(spot.x, spot.y, spot.w, spot.h)
                        .setInteractive()
                        .setOrigin(0.5);

                    const hotspot = { zone, ...spot };
                    this.hotspots.push(hotspot);

                    zone.on('pointerover', () => {
                        if (this.inventoryOpen || this.conversationActive) return;
                        this.setCrosshairHover(hotspot);
                    });

                    zone.on('pointerout', () => {
                        if (this.inventoryOpen || this.conversationActive) return;
                        this.setCrosshairHover(null);
                    });

                    zone.on('pointerdown', (pointer) => {
                        if (this.inventoryOpen) return;
                        this.handleHotspotPress(hotspot, pointer);
                    });
                });
            }

            // Override in subclass for room-specific actions
            executeAction(action, hotspot) {
                if (action === 'Look At') {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Use') {
                    this.showDialog(hotspot.useResponse);
                } else if (action === 'Talk To') {
                    this.showDialog(hotspot.talkResponse);
                }
            }

            // Override in subclass for room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                this.showDialog(`That doesn't work.`);
            }

            // ========== VERB COIN ==========

            createVerbCoin(width, height) {
                this.verbCoin = this.add.container(0, 0);
                this.verbCoin.setVisible(false);
                this.verbCoin.setDepth(5000);

                const scale = this.verbCoinScale;
                const coinRadius = this.verbCoinRadius;
                const actionRadius = this.verbActionRadius;

                // Gold coin background
                const coinBg = this.add.graphics();
                coinBg.fillStyle(0x8b6914, 1);
                coinBg.fillCircle(0, 0, coinRadius);
                coinBg.lineStyle(5 * scale, 0xd4a84b, 1);
                coinBg.strokeCircle(0, 0, coinRadius);
                coinBg.lineStyle(3 * scale, 0x5c4a0f, 0.6);
                coinBg.strokeCircle(0, 0, coinRadius - 10 * scale);
                this.verbCoin.add(coinBg);

                // Action buttons - positioned around top of coin so finger doesn't block them
                // Spread out enough to prevent overlap (actionRadius is 32 on desktop, 64 on mobile)
                const actions = [
                    { name: 'Use', icon: 'hand', color: 0x4CAF50, x: -62 * scale, y: 0 },
                    { name: 'Look At', icon: 'eye', color: 0x2196F3, x: 0, y: -62 * scale },
                    { name: 'Talk To', icon: 'mouth', color: 0xFFC107, x: 62 * scale, y: 0 }
                ];

                this.verbCoinActions = [];
                actions.forEach(action => {
                    const container = this.add.container(action.x, action.y);
                    const bg = this.add.graphics();
                    bg.fillStyle(0x3d2817, 0.9);
                    bg.fillCircle(0, 0, actionRadius);
                    bg.lineStyle(3 * scale, action.color, 0.8);
                    bg.strokeCircle(0, 0, actionRadius);
                    container.add(bg);

                    const icon = this.add.graphics();
                    this.drawVerbIcon(icon, action.icon, action.color);
                    container.add(icon);

                    this.verbCoinActions.push({
                        name: action.name,
                        bg: bg,
                        icon: icon,
                        color: action.color,
                        x: action.x,
                        y: action.y,
                        radius: actionRadius
                    });
                    this.verbCoin.add(container);
                });
            }

            drawVerbIcon(graphics, type, color) {
                graphics.clear();
                const s = this.verbCoinScale;
                graphics.lineStyle(3 * s, color, 1);
                graphics.fillStyle(color, 1);

                // Icons scaled based on device
                switch (type) {
                    case 'hand':
                        graphics.fillRoundedRect(-12 * s, -9 * s, 24 * s, 21 * s, 4 * s);
                        graphics.fillCircle(-9 * s, -15 * s, 4.5 * s);
                        graphics.fillCircle(-3 * s, -18 * s, 4.5 * s);
                        graphics.fillCircle(3 * s, -18 * s, 4.5 * s);
                        graphics.fillCircle(9 * s, -15 * s, 4.5 * s);
                        break;
                    case 'eye':
                        graphics.fillEllipse(0, 0, 27 * s, 15 * s);
                        graphics.fillStyle(0x000000, 1);
                        graphics.fillCircle(0, 0, 6 * s);
                        graphics.fillStyle(0xffffff, 1);
                        graphics.fillCircle(-1.5 * s, -1.5 * s, 2 * s);
                        break;
                    case 'mouth':
                        graphics.fillRoundedRect(-13 * s, -9 * s, 26 * s, 18 * s, 6 * s);
                        graphics.fillStyle(0x000000, 1);
                        graphics.fillRect(-8 * s, -3 * s, 5 * s, 3 * s);
                        graphics.fillRect(-1 * s, -3 * s, 5 * s, 3 * s);
                        graphics.fillRect(5 * s, -3 * s, 5 * s, 3 * s);
                        graphics.fillStyle(color, 1);
                        graphics.fillTriangle(-13 * s, 6 * s, -7 * s, 6 * s, -18 * s, 15 * s);
                        break;
                }
            }

            showVerbCoin(hotspot, x, y) {
                // Stop character movement when verb coin appears
                this.stopCharacterMovement();

                const { width, height } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;

                this.activeHotspot = hotspot;
                this.verbCoinVisible = true;
                this.hoveredAction = null;

                const coinRadius = this.verbCoinRadius;
                // Don't let verb coin overlap the hotspot label text at bottom
                const textBuffer = this.isMobile ? 80 : 50;
                const maxY = (this.hotspotLabelY || (height - 25)) - textBuffer - coinRadius;
                let coinX = Phaser.Math.Clamp(x, coinRadius + 10, width - coinRadius - 10) + scrollX;
                let coinY = Phaser.Math.Clamp(y, coinRadius + 10, maxY) + scrollY;

                this.verbCoin.setPosition(coinX, coinY);
                this.hotspotLabel.setText(hotspot.name);

                const actionRadius = this.verbActionRadius;
                const scale = this.verbCoinScale;
                this.verbCoinActions.forEach(action => {
                    action.bg.clear();
                    action.bg.fillStyle(0x3d2817, 0.9);
                    action.bg.fillCircle(0, 0, actionRadius);
                    action.bg.lineStyle(3 * scale, action.color, 0.8);
                    action.bg.strokeCircle(0, 0, actionRadius);
                });

                this.verbCoin.setVisible(true);
                this.verbCoin.setScale(0.3);
                this.verbCoin.setAlpha(0);

                this.tweens.add({
                    targets: this.verbCoin,
                    scale: 1,
                    alpha: 1,
                    duration: 120,
                    ease: 'Back.out'
                });
            }

            hideVerbCoin() {
                this.verbCoinVisible = false;
                this.hoveredAction = null;
                this.hotspotLabel.setText('');

                this.tweens.add({
                    targets: this.verbCoin,
                    scale: 0.3,
                    alpha: 0,
                    duration: 80,
                    ease: 'Power2',
                    onComplete: () => {
                        this.verbCoin.setVisible(false);
                        this.activeHotspot = null;
                        this.activeInventoryItem = null;
                    }
                });
            }

            updateVerbCoinHover(pointer) {
                if (!this.verbCoinVisible) return;

                const coinX = this.verbCoin.x;
                const coinY = this.verbCoin.y;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;
                const pointerX = pointer.x + scrollX;
                const pointerY = pointer.y + scrollY;

                let foundHover = null;

                this.verbCoinActions.forEach(action => {
                    const actionX = coinX + action.x;
                    const actionY = coinY + action.y;
                    const dist = Phaser.Math.Distance.Between(pointerX, pointerY, actionX, actionY);

                    const actionRadius = this.verbActionRadius;
                    const hoverRadius = this.verbActionHoverRadius;
                    const scale = this.verbCoinScale;
                    if (dist <= action.radius + 5) {
                        foundHover = action.name;
                        action.bg.clear();
                        action.bg.fillStyle(action.color, 0.4);
                        action.bg.fillCircle(0, 0, hoverRadius);
                        action.bg.lineStyle(3 * scale, action.color, 1);
                        action.bg.strokeCircle(0, 0, hoverRadius);
                    } else {
                        action.bg.clear();
                        action.bg.fillStyle(0x3d2817, 0.9);
                        action.bg.fillCircle(0, 0, actionRadius);
                        action.bg.lineStyle(3 * scale, action.color, 0.8);
                        action.bg.strokeCircle(0, 0, actionRadius);
                    }
                });

                this.hoveredAction = foundHover;
                this.updateActionSentence(foundHover);
            }

            updateActionSentence(action) {
                let targetName = '';
                if (this.activeHotspot) targetName = this.activeHotspot.name;
                else if (this.activeInventoryItem) targetName = this.activeInventoryItem.name;

                if (!action || !targetName) {
                    this.hotspotLabel.setText(targetName);
                    return;
                }

                // Get custom verb labels from hotspot, or use defaults
                const verbLabels = this.activeHotspot?.verbLabels || {};
                let verbText = '';

                switch (action) {
                    case 'Use':
                        verbText = verbLabels.actionVerb || 'Use';
                        break;
                    case 'Look At':
                        verbText = verbLabels.lookVerb || 'Examine';
                        break;
                    case 'Talk To':
                        verbText = verbLabels.talkVerb || 'Talk to';
                        break;
                    default:
                        verbText = action;
                }

                this.hotspotLabel.setText(`${verbText} ${targetName}`);
            }

            showInventoryVerbCoin(item, x, y) {
                const { width, height } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;

                this.activeInventoryItem = item;
                this.activeHotspot = null;
                this.verbCoinVisible = true;
                this.hoveredAction = null;

                this.verbCoin.setDepth(5000);

                const coinRadius = this.verbCoinRadius;
                // Don't let verb coin overlap the hotspot label text at bottom
                const textBuffer = this.isMobile ? 80 : 50;
                const maxY = (this.hotspotLabelY || (height - 25)) - textBuffer - coinRadius;
                let coinX = Phaser.Math.Clamp(x, coinRadius + 10, width - coinRadius - 10) + scrollX;
                let coinY = Phaser.Math.Clamp(y, coinRadius + 10, maxY) + scrollY;

                this.verbCoin.setPosition(coinX, coinY);
                this.hotspotLabel.setText(item.name);

                const actionRadius = this.verbActionRadius;
                const scale = this.verbCoinScale;
                this.verbCoinActions.forEach(action => {
                    action.bg.clear();
                    action.bg.fillStyle(0x3d2817, 0.9);
                    action.bg.fillCircle(0, 0, actionRadius);
                    action.bg.lineStyle(3 * scale, action.color, 0.8);
                    action.bg.strokeCircle(0, 0, actionRadius);
                });

                this.verbCoin.setVisible(true);
                this.verbCoin.setScale(0.3);
                this.verbCoin.setAlpha(0);

                this.tweens.add({
                    targets: this.verbCoin,
                    scale: 1,
                    alpha: 1,
                    duration: 120,
                    ease: 'Back.out'
                });
            }

            performInventoryItemAction(action, item) {
                if (action === 'Use') {
                    this.selectItem(item, this.pressedInventorySlot);
                } else if (action === 'Look At') {
                    this.showDialog(item.description || `It's a ${item.name}.`);
                } else if (action === 'Talk To') {
                    this.showDialog(`The ${item.name} isn't much of a conversationalist.`);
                }
            }

            // ========== CURSOR ==========

            createCrosshairCursor(width, height) {
                this.crosshairCursor = this.add.container(width / 2, height / 2);
                this.crosshairCursor.setDepth(9000);
                this.crosshairGraphics = this.add.graphics();
                this.drawCrosshair(0xffffff);
                this.crosshairCursor.add(this.crosshairGraphics);

                // Create arrow cursor (for edge zone transitions)
                this.arrowCursor = this.add.container(width / 2, height / 2);
                this.arrowCursor.setDepth(6000);
                this.arrowCursor.setVisible(false);
                this.arrowGraphics = this.add.graphics();
                this.arrowCursor.add(this.arrowGraphics);

                // Larger text on mobile for readability
                const fontSize = this.isMobile ? '24px' : '14px';
                const strokeThickness = this.isMobile ? 5 : 3;
                const bottomPadding = this.isMobile ? 45 : 25;
                this.hotspotLabelY = height - bottomPadding;

                this.hotspotLabel = this.add.text(width / 2, this.hotspotLabelY, '', {
                    fontFamily: '"Press Start 2P", cursive',
                    fontSize: fontSize,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: strokeThickness,
                    align: 'center'
                }).setOrigin(0.5).setDepth(6000);
            }

            drawCrosshair(color) {
                this.crosshairGraphics.clear();
                // Larger crosshair on mobile
                const scale = this.isMobile ? 2 : 1;
                const lineWidth = 4 * scale;
                const outer = 20 * scale;
                const inner = 8 * scale;
                this.crosshairGraphics.lineStyle(lineWidth, color, 1);
                this.crosshairGraphics.moveTo(-outer, 0); this.crosshairGraphics.lineTo(-inner, 0);
                this.crosshairGraphics.moveTo(inner, 0); this.crosshairGraphics.lineTo(outer, 0);
                this.crosshairGraphics.moveTo(0, -outer); this.crosshairGraphics.lineTo(0, -inner);
                this.crosshairGraphics.moveTo(0, inner); this.crosshairGraphics.lineTo(0, outer);
                this.crosshairGraphics.strokePath();
            }

            // Draw pixelated arrow cursor for edge zones
            drawArrowCursor(direction) {
                this.arrowGraphics.clear();
                const scale = this.isMobile ? 2 : 1;
                const p = 4 * scale; // Pixel size for pixelated look

                this.arrowGraphics.fillStyle(0xff0000, 1);

                if (direction === 'left') {
                    // Pixelated left-pointing arrow
                    // Arrow tip
                    this.arrowGraphics.fillRect(-6 * p, -1 * p, p, 2 * p);
                    this.arrowGraphics.fillRect(-5 * p, -2 * p, p, 4 * p);
                    this.arrowGraphics.fillRect(-4 * p, -3 * p, p, 6 * p);
                    this.arrowGraphics.fillRect(-3 * p, -4 * p, p, 8 * p);
                    // Arrow shaft
                    this.arrowGraphics.fillRect(-2 * p, -2 * p, 6 * p, 4 * p);
                } else if (direction === 'up') {
                    // Pixelated up-pointing arrow
                    // Arrow tip
                    this.arrowGraphics.fillRect(-1 * p, -6 * p, 2 * p, p);
                    this.arrowGraphics.fillRect(-2 * p, -5 * p, 4 * p, p);
                    this.arrowGraphics.fillRect(-3 * p, -4 * p, 6 * p, p);
                    this.arrowGraphics.fillRect(-4 * p, -3 * p, 8 * p, p);
                    // Arrow shaft
                    this.arrowGraphics.fillRect(-2 * p, -2 * p, 4 * p, 6 * p);
                } else {
                    // Pixelated right-pointing arrow
                    // Arrow tip
                    this.arrowGraphics.fillRect(5 * p, -1 * p, p, 2 * p);
                    this.arrowGraphics.fillRect(4 * p, -2 * p, p, 4 * p);
                    this.arrowGraphics.fillRect(3 * p, -3 * p, p, 6 * p);
                    this.arrowGraphics.fillRect(2 * p, -4 * p, p, 8 * p);
                    // Arrow shaft
                    this.arrowGraphics.fillRect(-4 * p, -2 * p, 6 * p, 4 * p);
                }

                this.arrowDirection = direction;
            }

            // Show arrow cursor (hide crosshair)
            showArrowCursor(direction) {
                this.drawArrowCursor(direction);
                this.crosshairCursor.setVisible(false);
                this.arrowCursor.setVisible(true);
            }

            // Hide arrow cursor (show crosshair)
            hideArrowCursor() {
                this.arrowCursor.setVisible(false);
                const state = this.getGameState();
                if (!state.selectedItem) {
                    this.crosshairCursor.setVisible(true);
                }
                this.arrowDirection = null;
            }

            setCrosshairHover(hotspot) {
                this.currentHoveredHotspot = hotspot;
                const selectedItem = this.getGameState().selectedItem;

                if (hotspot) {
                    this.drawCrosshair(0xff0000);
                    if (selectedItem) {
                        this.hotspotLabel.setText(`Use ${selectedItem.name} on ${hotspot.name}`);
                        // Show red outline on item cursor when over a hotspot
                        this.showItemCursorHighlight();
                    } else {
                        this.hotspotLabel.setText(hotspot.name);
                        this.hideItemCursorHighlight();
                    }
                } else {
                    this.drawCrosshair(0xffffff);
                    this.hideItemCursorHighlight();
                    if (selectedItem) {
                        this.hotspotLabel.setText(selectedItem.name);
                    } else {
                        this.hotspotLabel.setText('');
                    }
                }
            }

            showItemCursorHighlight() {
                if (!this.itemCursorHighlight) return;
                this.itemCursorHighlight.setVisible(true);
            }

            hideItemCursorHighlight() {
                if (!this.itemCursorHighlight) return;
                this.itemCursorHighlight.setVisible(false);
            }

            createItemCursor() {
                this.itemCursor = this.add.container(0, 0);
                this.itemCursor.setDepth(5000);
                this.itemCursor.setVisible(false);
            }

            // ========== INVENTORY ==========

            createInventoryUI(width, height) {
                this.inventoryPanel = this.add.container(width / 2, height / 2);
                this.inventoryPanel.setVisible(false);
                this.inventoryPanel.setDepth(2500);

                const panelWidth = width - 100;
                const panelHeight = height - 120;

                const panelBg = this.add.graphics();
                panelBg.fillStyle(0x1a1a2e, 0.95);
                panelBg.fillRoundedRect(-panelWidth / 2, -panelHeight / 2, panelWidth, panelHeight, 15);
                panelBg.lineStyle(3, 0x4a4a6a, 1);
                panelBg.strokeRoundedRect(-panelWidth / 2, -panelHeight / 2, panelWidth, panelHeight, 15);
                this.inventoryPanel.add(panelBg);

                const title = this.add.text(0, -panelHeight / 2 + 30, 'INVENTORY', {
                    fontFamily: '"Press Start 2P", cursive',
                    fontSize: '20px',
                    color: '#ffffff'
                }).setOrigin(0.5);
                this.inventoryPanel.add(title);

                // Slots (5x3 grid)
                const slotSize = 80, slotPadding = 15;
                const gridCols = 5, gridRows = 3;
                const gridWidth = gridCols * (slotSize + slotPadding) - slotPadding;
                const gridHeight = gridRows * (slotSize + slotPadding) - slotPadding;
                const startX = -gridWidth / 2 + slotSize / 2;
                const startY = -gridHeight / 2 + slotSize / 2 + 25;

                for (let row = 0; row < gridRows; row++) {
                    for (let col = 0; col < gridCols; col++) {
                        const slotX = startX + col * (slotSize + slotPadding);
                        const slotY = startY + row * (slotSize + slotPadding);

                        const slotBg = this.add.graphics();
                        slotBg.fillStyle(0x2a2a4a, 1);
                        slotBg.fillRoundedRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize, 6);
                        slotBg.lineStyle(2, 0x4a4a6a, 1);
                        slotBg.strokeRoundedRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize, 6);
                        this.inventoryPanel.add(slotBg);

                        const display = this.add.container(slotX, slotY);
                        this.inventoryPanel.add(display);

                        this.inventorySlots.push({ x: slotX, y: slotY, size: slotSize, display, item: null });
                    }
                }

                this.selectedSlotHighlight = this.add.graphics();
                this.selectedSlotHighlight.setDepth(2501);
                this.selectedSlotHighlight.setVisible(false);

                // Mobile inventory button (top right corner)
                if (this.isMobile) {
                    const btnSize = 90;
                    this.inventoryButtonArea = { x: width - btnSize/2 - 15, y: btnSize/2 + 15, size: btnSize };

                    this.inventoryButton = this.add.container(this.inventoryButtonArea.x, this.inventoryButtonArea.y);
                    this.inventoryButton.setDepth(4000);
                    this.inventoryButton.setScrollFactor(0);

                    // Button background
                    const btnBg = this.add.graphics();
                    btnBg.fillStyle(0x4a3728, 0.9);
                    btnBg.fillRoundedRect(-btnSize/2, -btnSize/2, btnSize, btnSize, 12);
                    btnBg.lineStyle(4, 0x8b6914, 1);
                    btnBg.strokeRoundedRect(-btnSize/2, -btnSize/2, btnSize, btnSize, 12);
                    this.inventoryButton.add(btnBg);

                    // Backpack icon (scaled up)
                    const icon = this.add.graphics();
                    icon.fillStyle(0xc9a227, 1);
                    // Bag body
                    icon.fillRoundedRect(-24, -10, 48, 36, 8);
                    // Bag flap
                    icon.fillRoundedRect(-18, -22, 36, 16, 5);
                    // Bag clasp
                    icon.fillStyle(0x8b6914, 1);
                    icon.fillCircle(0, -8, 7);
                    icon.fillStyle(0x4a3728, 1);
                    icon.fillCircle(0, -8, 3);
                    this.inventoryButton.add(icon);

                }
            }

            toggleInventory() {
                this.inventoryOpen = !this.inventoryOpen;

                if (this.inventoryOpen) {
                    // Stop character movement when inventory opens
                    this.stopCharacterMovement();
                    this.setCrosshairHover(null);

                    const { width, height } = this.scale;
                    const scrollX = this.cameras.main.scrollX || 0;
                    const scrollY = this.cameras.main.scrollY || 0;
                    this.inventoryPanel.setPosition(scrollX + width / 2, scrollY + height / 2);

                    this.inventoryPanel.setVisible(true);
                    this.inventoryPanel.setScale(0.8);
                    this.inventoryPanel.setAlpha(0);
                    this.tweens.add({
                        targets: this.inventoryPanel,
                        scale: 1,
                        alpha: 1,
                        duration: 150,
                        ease: 'Back.out'
                    });
                } else {
                    this.selectedSlotHighlight.setVisible(false);
                    if (this.inventoryItemPressTimer) {
                        this.inventoryItemPressTimer.remove();
                        this.inventoryItemPressTimer = null;
                    }
                    this.pressedInventoryItem = null;
                    this.pressedInventorySlot = null;
                    if (this.itemOutsideInventoryTimer) {
                        this.itemOutsideInventoryTimer.remove();
                        this.itemOutsideInventoryTimer = null;
                    }

                    this.drawCrosshair(0xffffff);
                    this.hotspotLabel.setText('');

                    this.tweens.add({
                        targets: this.inventoryPanel,
                        scale: 0.8,
                        alpha: 0,
                        duration: 100,
                        ease: 'Power2',
                        onComplete: () => this.inventoryPanel.setVisible(false)
                    });
                }
            }

            checkItemOutsideInventory(pointer) {
                const { width, height } = this.scale;
                const panelWidth = width - 100;
                const panelHeight = height - 120;
                const panelLeft = (width - panelWidth) / 2;
                const panelRight = panelLeft + panelWidth;
                const panelTop = (height - panelHeight) / 2;
                const panelBottom = panelTop + panelHeight;

                const isOutside = pointer.x < panelLeft || pointer.x > panelRight ||
                                  pointer.y < panelTop || pointer.y > panelBottom;

                if (isOutside) {
                    if (!this.itemOutsideInventoryTimer) {
                        this.itemOutsideInventoryTimer = this.time.delayedCall(100, () => {
                            if (this.inventoryOpen && this.getGameState().selectedItem) this.toggleInventory();
                            this.itemOutsideInventoryTimer = null;
                        });
                    }
                } else {
                    if (this.itemOutsideInventoryTimer) {
                        this.itemOutsideInventoryTimer.remove();
                        this.itemOutsideInventoryTimer = null;
                    }
                }
            }

            addToInventory(item) {
                // Prevent duplicates
                if (this.hasItem(item.id)) {
                    console.log('[' + this.scene.key + '] Item already in inventory:', item.id);
                    return false;
                }

                const state = this.getGameState();
                state.inventory.push(item);
                this.setGameState(state);

                console.log('[' + this.scene.key + '] Added to inventory:', item.id, 'Total items:', state.inventory.length);

                this.addItemToSlot(item);

                if (this.cache.audio.exists('pickupSound')) {
                    this.sound.play('pickupSound', { volume: 0.7 });
                }

                return true;
            }

            addItemToSlot(item) {
                const emptySlot = this.inventorySlots.find(slot => slot.item === null);
                if (!emptySlot) return false;

                emptySlot.item = item;
                emptySlot.display.removeAll(true);

                const itemSize = 50;
                const itemGraphic = this.add.graphics();
                itemGraphic.fillStyle(item.color || 0xffd700, 1);
                itemGraphic.fillRoundedRect(-itemSize / 2, -itemSize / 2, itemSize, itemSize, 8);
                itemGraphic.lineStyle(2, 0x000000, 0.3);
                itemGraphic.strokeRoundedRect(-itemSize / 2, -itemSize / 2, itemSize, itemSize, 8);
                emptySlot.display.add(itemGraphic);

                const slotSize = emptySlot.size;
                const hitArea = this.add.rectangle(0, 0, slotSize - 4, slotSize - 4, 0x000000, 0).setInteractive();

                hitArea.on('pointerdown', (pointer) => {
                    if (!pointer.leftButtonDown()) return;
                    this.clickedUI = true;
                    this.pressedInventoryItem = item;
                    this.pressedInventorySlot = emptySlot;

                    if (this.inventoryItemPressTimer) this.inventoryItemPressTimer.remove();
                    this.inventoryItemPressTimer = this.time.delayedCall(this.verbCoinDelay, () => {
                        this.showInventoryVerbCoin(item, pointer.x, pointer.y);
                    });
                });

                hitArea.on('pointerup', () => {
                    if (!this.verbCoinVisible && this.pressedInventoryItem && this.pressedInventoryItem.id === item.id) {
                        this.selectItem(item, emptySlot);
                        this.pressedInventoryItem = null;
                        this.pressedInventorySlot = null;
                    }
                });

                hitArea.on('pointerover', () => {
                    this.drawCrosshair(0xff0000);
                    this.hotspotLabel.setText(item.name);
                });

                hitArea.on('pointerout', () => {
                    this.drawCrosshair(0xffffff);
                    this.hotspotLabel.setText('');
                });

                emptySlot.display.add(hitArea);
                return true;
            }

            hasItem(itemId) {
                return this.getGameState().inventory.some(item => item.id === itemId);
            }

            removeFromInventory(itemId) {
                const state = this.getGameState();
                const index = state.inventory.findIndex(item => item.id === itemId);
                if (index === -1) return false;

                state.inventory.splice(index, 1);
                this.setGameState(state);

                const slot = this.inventorySlots.find(s => s.item && s.item.id === itemId);
                if (slot) {
                    slot.display.removeAll(true);
                    slot.item = null;
                }

                return true;
            }

            selectItem(item, slot) {
                const state = this.getGameState();

                if (state.selectedItem && state.selectedItem.id === item.id) {
                    this.deselectItem();
                    return;
                }

                state.selectedItem = item;
                this.setGameState(state);

                this.crosshairCursor.setVisible(false);

                this.itemCursor.removeAll(true);
                const cursorBg = this.add.graphics();
                cursorBg.fillStyle(item.color || 0xffd700, 1);
                cursorBg.fillRoundedRect(-25, -25, 50, 50, 8);
                cursorBg.lineStyle(2, 0xffffff, 0.8);
                cursorBg.strokeRoundedRect(-25, -25, 50, 50, 8);
                this.itemCursor.add(cursorBg);

                // Red outline highlight (shown when over hotspot)
                this.itemCursorHighlight = this.add.graphics();
                this.itemCursorHighlight.lineStyle(4, 0xff0000, 1);
                this.itemCursorHighlight.strokeRoundedRect(-29, -29, 58, 58, 10);
                this.itemCursorHighlight.setVisible(false);
                this.itemCursor.add(this.itemCursorHighlight);

                this.itemCursor.setVisible(true);

                this.hotspotLabel.setText(item.name);
            }

            deselectItem() {
                const state = this.getGameState();
                state.selectedItem = null;
                this.setGameState(state);

                this.itemCursor.setVisible(false);
                this.itemCursor.removeAll(true);
                this.selectedSlotHighlight.setVisible(false);
                this.crosshairCursor.setVisible(true);
                this.hotspotLabel.setText('');
                this.hideItemCursorHighlight();
            }

            // ========== DIALOGUE ==========

            createDialogUI(width, height) {
                this.speechBubble = this.add.container(0, 0);
                this.speechBubble.setDepth(7000);
                this.speechBubble.setVisible(false);

                // Larger text on mobile for readability
                const fontSize = this.isMobile ? '24px' : '14px';
                const strokeThickness = this.isMobile ? 5 : 3;
                const lineSpacing = this.isMobile ? 12 : 8;

                this.dialogText = this.add.text(0, 0, '', {
                    fontFamily: '"Press Start 2P", cursive',
                    fontSize: fontSize,
                    color: '#ffffff',
                    align: 'center',
                    wordWrap: { width: width * 0.7 },
                    lineSpacing: lineSpacing,
                    stroke: '#000000',
                    strokeThickness: strokeThickness
                }).setOrigin(0.5);
                this.speechBubble.add(this.dialogText);
            }

            showDialog(text, onComplete = null) {
                if (this.dialogTimer) this.dialogTimer.remove();
                this.dialogQueue = [];
                this.dialogCallback = onComplete;

                const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

                if (sentences.length > 1) {
                    this.dialogQueue = sentences.slice(1).map(s => s.trim());
                    this.startDialogSequence();
                    this.showSingleDialog(sentences[0].trim(), true);
                } else {
                    this.showSingleDialog(text, false);
                }
            }

            startDialogSequence() {
                this.dialogActive = true;
                this.dialogSkipReady = false;
                if (this.walkTween) { this.walkTween.stop(); this.walkTween = null; }
                this.isWalking = false;
                this.stopWalkAnimation();
                if (this.crosshairCursor) this.crosshairCursor.setVisible(false);
                this.time.delayedCall(200, () => { this.dialogSkipReady = true; });
            }

            endDialogSequence() {
                this.dialogActive = false;
                this.dialogSkipReady = false;
                const state = this.getGameState();
                if (this.crosshairCursor && !state.selectedItem) this.crosshairCursor.setVisible(true);
            }

            skipToNextDialog() {
                if (!this.dialogActive || !this.dialogSkipReady) return;
                if (this.dialogTimer) { this.dialogTimer.remove(); this.dialogTimer = null; }

                if (this.dialogQueue.length > 0) {
                    this.dialogSkipReady = false;
                    this.showSingleDialog(this.dialogQueue.shift(), true);
                    this.time.delayedCall(150, () => { this.dialogSkipReady = true; });
                } else {
                    this.speechBubble.setVisible(false);
                    this.dialogText.setText('');
                    this.endDialogSequence();
                    // Call callback if provided
                    if (this.dialogCallback) {
                        const callback = this.dialogCallback;
                        this.dialogCallback = null;
                        callback();
                    }
                }
            }

            showSingleDialog(text, isSequence = false) {
                if (isSequence && !this.dialogActive) {
                    this.startDialogSequence();
                }

                this.dialogText.setText(text);
                this.updateSpeechBubblePosition();
                this.speechBubble.setVisible(true);

                const displayTime = Math.max(1500, text.length * 40);
                this.dialogTimer = this.time.delayedCall(displayTime, () => {
                    if (this.dialogQueue.length > 0) {
                        this.showSingleDialog(this.dialogQueue.shift(), true);
                    } else {
                        this.speechBubble.setVisible(false);
                        this.dialogText.setText('');
                        if (isSequence) this.endDialogSequence();
                        // Call callback if provided
                        if (this.dialogCallback) {
                            const callback = this.dialogCallback;
                            this.dialogCallback = null;
                            callback();
                        }
                    }
                });
            }

            updateSpeechBubblePosition() {
                if (!this.speechBubble || !this.player) return;

                const { width } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;

                let textX = this.player.x;
                let textY = this.player.y - 310;

                const halfWidth = this.dialogText.width / 2;
                const camLeft = scrollX + halfWidth + 10;
                const camRight = scrollX + width - halfWidth - 10;
                textX = Phaser.Math.Clamp(textX, camLeft, camRight);

                this.speechBubble.setPosition(textX, textY);
            }

            // ========== CONVERSATION SYSTEM (NPC Dialogue Trees) ==========

            createConversationUI(width, height) {
                // Dialogue options panel (bottom-left)
                this.dialogueOptionsUI = this.add.container(0, 0);
                this.dialogueOptionsUI.setDepth(8000);
                this.dialogueOptionsUI.setScrollFactor(0);
                this.dialogueOptionsUI.setVisible(false);

                // NPC speech bubble (positioned above NPC)
                this.npcSpeechBubble = this.add.container(0, 0);
                this.npcSpeechBubble.setDepth(7000);
                this.npcSpeechBubble.setVisible(false);

                const fontSize = this.isMobile ? '22px' : '13px';
                const strokeThickness = this.isMobile ? 4 : 3;

                this.npcDialogText = this.add.text(0, 0, '', {
                    fontFamily: '"Press Start 2P", cursive',
                    fontSize: fontSize,
                    color: '#aaffaa',
                    align: 'center',
                    wordWrap: { width: width * 0.6 },
                    lineSpacing: this.isMobile ? 10 : 6,
                    stroke: '#000000',
                    strokeThickness: strokeThickness
                }).setOrigin(0.5);
                this.npcSpeechBubble.add(this.npcDialogText);
            }

            enterConversation(npcData, dialogueTree) {
                console.log('[Conversation] enterConversation called');
                console.log('[Conversation] npcData:', npcData);
                console.log('[Conversation] dialogueTree:', dialogueTree);

                this.conversationActive = true;
                this.conversationNPC = npcData;
                this.conversationData = dialogueTree;
                this.conversationState = 'start';

                // Freeze movement and hide normal UI
                this.stopCharacterMovement();
                if (this.verbCoin) this.verbCoin.setVisible(false);
                this.verbCoinVisible = false;

                // Keep crosshair visible during conversation
                if (this.crosshairCursor) this.crosshairCursor.setVisible(true);
                this.drawCrosshair(0xffffff); // White cursor

                // Show initial dialogue options
                console.log('[Conversation] Calling showDialogueOptions with start');
                this.showDialogueOptions('start');
            }

            exitConversation() {
                this.conversationActive = false;
                this.conversationNPC = null;
                this.conversationData = null;
                this.conversationState = null;
                this.awaitingNPCResponse = false;

                // Hide conversation UI
                this.dialogueOptionsUI.setVisible(false);
                this.npcSpeechBubble.setVisible(false);
                this.speechBubble.setVisible(false);

                // Clear dialogue option texts
                this.dialogueOptionTexts.forEach(t => t.destroy());
                this.dialogueOptionTexts = [];

                // Clear hotspot label
                if (this.hotspotLabel) this.hotspotLabel.setText('');

                // Restore normal cursor state
                const state = this.getGameState();
                if (this.crosshairCursor && !state.selectedItem) {
                    this.crosshairCursor.setVisible(true);
                    this.drawCrosshair(0xffffff);
                }
            }

            showDialogueOptions(nodeKey) {
                console.log('[Conversation] showDialogueOptions called with nodeKey:', nodeKey);
                const { width, height } = this.scale;
                console.log('[Conversation] conversationData:', this.conversationData);

                // Clear previous options
                this.dialogueOptionTexts.forEach(t => t.destroy());
                this.dialogueOptionTexts = [];
                this.dialogueOptionsUI.removeAll(true);

                const node = this.conversationData[nodeKey];
                console.log('[Conversation] node found:', node);
                if (!node || !node.options) {
                    console.log('[Conversation] No node or options, exiting');
                    this.exitConversation();
                    return;
                }

                // Filter out options that shouldn't show
                const visibleOptions = node.options.filter(opt => {
                    if (opt.condition) {
                        return opt.condition(this);
                    }
                    return true;
                });

                console.log('[Conversation] visibleOptions:', visibleOptions.length, visibleOptions);
                if (visibleOptions.length === 0) {
                    console.log('[Conversation] No visible options, exiting');
                    this.exitConversation();
                    return;
                }

                // Panel background
                const panelPadding = this.isMobile ? 20 : 15;
                const optionHeight = this.isMobile ? 50 : 32;
                const panelWidth = this.isMobile ? width * 0.85 : width * 0.45;
                const panelHeight = panelPadding * 2 + visibleOptions.length * optionHeight;
                const panelX = panelPadding;
                const panelY = height - panelHeight - panelPadding;

                const bg = this.add.graphics();
                bg.fillStyle(0x1a1a2a, 0.95);
                bg.fillRoundedRect(panelX, panelY, panelWidth, panelHeight, 8);
                bg.lineStyle(2, 0x4a4a6a, 1);
                bg.strokeRoundedRect(panelX, panelY, panelWidth, panelHeight, 8);
                bg.setScrollFactor(0);
                this.dialogueOptionsUI.add(bg);

                // Add options as clickable text
                const fontSize = this.isMobile ? '18px' : '11px';
                visibleOptions.forEach((opt, index) => {
                    const optY = panelY + panelPadding + index * optionHeight + optionHeight / 2;
                    const optX = panelX + panelPadding + 15;

                    // Bullet point
                    const bullet = this.add.text(panelX + panelPadding, optY, '>', {
                        fontFamily: '"Press Start 2P", cursive',
                        fontSize: fontSize,
                        color: '#ffcc00'
                    }).setOrigin(0, 0.5).setScrollFactor(0);
                    this.dialogueOptionsUI.add(bullet);

                    const optText = this.add.text(optX, optY, opt.text, {
                        fontFamily: '"Press Start 2P", cursive',
                        fontSize: fontSize,
                        color: opt.used ? '#666666' : '#ffffff',
                        wordWrap: { width: panelWidth - panelPadding * 2 - 20 }
                    }).setOrigin(0, 0.5).setScrollFactor(0);

                    optText.setInteractive();

                    optText.on('pointerover', () => {
                        if (!opt.used) optText.setColor('#ffcc00');
                        bullet.setColor('#ffffff');
                        this.drawCrosshair(0xff0000); // Red cursor on hover
                    });

                    optText.on('pointerout', () => {
                        optText.setColor(opt.used ? '#666666' : '#ffffff');
                        bullet.setColor('#ffcc00');
                        this.drawCrosshair(0xffffff); // White cursor
                    });

                    optText.on('pointerdown', () => {
                        // Set flag to prevent the global click handler from immediately skipping
                        this.justClickedDialogueOption = true;
                        this.handleDialogueChoice(opt, nodeKey);
                        // Clear the flag after a short delay
                        this.time.delayedCall(100, () => {
                            this.justClickedDialogueOption = false;
                        });
                    });

                    this.dialogueOptionTexts.push(optText);
                    this.dialogueOptionTexts.push(bullet);
                    this.dialogueOptionsUI.add(optText);
                });

                // Position at (0,0) since scrollFactor is 0 (screen-fixed)
                this.dialogueOptionsUI.setPosition(0, 0);
                this.dialogueOptionsUI.setVisible(true);
                console.log('[Conversation] dialogueOptionsUI visible:', this.dialogueOptionsUI.visible);
                console.log('[Conversation] dialogueOptionsUI position:', this.dialogueOptionsUI.x, this.dialogueOptionsUI.y);
            }

            handleDialogueChoice(option, currentNode) {
                console.log('[Conversation] handleDialogueChoice called');
                console.log('[Conversation] option:', option);
                console.log('[Conversation] option.heroLine:', option.heroLine);
                console.log('[Conversation] currentNode:', currentNode);

                // Hide options while dialogue plays
                this.dialogueOptionsUI.setVisible(false);
                this.awaitingNPCResponse = true;

                // Mark option as used if it has a flag
                if (option.setFlag) {
                    this.setFlag(option.setFlag, true);
                }
                option.used = true;

                // Hero says their line
                console.log('[Conversation] About to call showConversationLine with heroLine:', option.heroLine);
                this.showConversationLine(option.heroLine, 'hero', () => {
                    // Then NPC responds
                    if (option.npcResponse) {
                        this.showConversationLine(option.npcResponse, 'npc', () => {
                            this.awaitingNPCResponse = false;
                            // Move to next node or show options again
                            if (option.exit) {
                                this.exitConversation();
                            } else if (option.nextNode) {
                                this.conversationState = option.nextNode;
                                this.showDialogueOptions(option.nextNode);
                            } else {
                                // Stay on current node
                                this.showDialogueOptions(currentNode);
                            }
                        });
                    } else {
                        this.awaitingNPCResponse = false;
                        if (option.exit) {
                            this.exitConversation();
                        } else if (option.nextNode) {
                            this.conversationState = option.nextNode;
                            this.showDialogueOptions(option.nextNode);
                        } else {
                            this.showDialogueOptions(currentNode);
                        }
                    }
                });
            }

            showConversationLine(text, speaker, onComplete) {
                const { width } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;

                console.log('[Conversation] showConversationLine called:', { text, speaker });

                // Store callback for skip functionality
                this.conversationLineCallback = onComplete;
                this.conversationLineSpeaker = speaker;

                if (speaker === 'hero') {
                    // Use existing speech bubble for hero
                    console.log('[Conversation] Showing hero line:', text);
                    console.log('[Conversation] speechBubble:', this.speechBubble);
                    console.log('[Conversation] dialogText:', this.dialogText);
                    this.dialogText.setText(text);
                    this.updateSpeechBubblePosition();
                    this.speechBubble.setVisible(true);
                    this.npcSpeechBubble.setVisible(false);
                    console.log('[Conversation] Hero speech bubble visible:', this.speechBubble.visible);
                    console.log('[Conversation] Hero speech bubble position:', this.speechBubble.x, this.speechBubble.y);
                } else {
                    // Use NPC speech bubble
                    this.npcDialogText.setText(text);

                    // Position above NPC (use conversationNPC position)
                    let npcX = this.conversationNPC.x;
                    let npcY = this.conversationNPC.y - 280;

                    const halfWidth = this.npcDialogText.width / 2;
                    const camLeft = scrollX + halfWidth + 10;
                    const camRight = scrollX + width - halfWidth - 10;
                    npcX = Phaser.Math.Clamp(npcX, camLeft, camRight);

                    this.npcSpeechBubble.setPosition(npcX, npcY);
                    this.npcSpeechBubble.setVisible(true);
                    this.speechBubble.setVisible(false);
                }

                // Auto-advance after delay
                const displayTime = Math.max(1500, text.length * 45);
                this.conversationLineTimer = this.time.delayedCall(displayTime, () => {
                    this.finishConversationLine();
                });
            }

            finishConversationLine() {
                if (this.conversationLineTimer) {
                    this.conversationLineTimer.remove();
                    this.conversationLineTimer = null;
                }

                if (this.conversationLineSpeaker === 'hero') {
                    this.speechBubble.setVisible(false);
                } else {
                    this.npcSpeechBubble.setVisible(false);
                }

                const callback = this.conversationLineCallback;
                this.conversationLineCallback = null;
                this.conversationLineSpeaker = null;

                if (callback) callback();
            }

            skipConversationLine() {
                if (this.conversationActive && this.conversationLineCallback) {
                    this.finishConversationLine();
                }
            }

            // ========== SCENE TRANSITION ==========

            transitionToScene(targetScene, spawnPoint) {
                const state = this.getGameState();
                console.log('[' + this.scene.key + '] Transitioning to', targetScene, 'with state:', {
                    inventory: state.inventory ? state.inventory.map(i => i.id) : [],
                    flags: state.flags
                });

                this.registry.set('spawnPoint', spawnPoint);

                this.cameras.main.fadeOut(500, 0, 0, 0);
                this.cameras.main.once('camerafadeoutcomplete', () => {
                    this.scene.start(targetScene);
                });
            }

            // ========== UPDATE ==========

            update() {
                const pointer = this.input.activePointer;
                const { width, height } = this.scale;
                const scrollX = this.cameras.main.scrollX || 0;
                const scrollY = this.cameras.main.scrollY || 0;

                // Update crosshair position
                if (this.crosshairCursor && this.crosshairCursor.visible) {
                    this.crosshairCursor.setPosition(pointer.x + scrollX, pointer.y + scrollY);
                }

                // Update arrow cursor position
                if (this.arrowCursor && this.arrowCursor.visible) {
                    this.arrowCursor.setPosition(pointer.x + scrollX, pointer.y + scrollY);
                }

                // Update item cursor position
                const selectedItem = this.getGameState().selectedItem;
                if (selectedItem && this.itemCursor && this.itemCursor.visible) {
                    this.itemCursor.setPosition(pointer.x + scrollX + 20, pointer.y + scrollY + 20);
                }

                // Update hotspot label position - follows cursor/verb coin/item cursor
                if (this.hotspotLabel) {
                    let labelX, labelY;
                    const labelOffset = this.isMobile ? 80 : 50;

                    if (this.verbCoinVisible && this.verbCoin) {
                        // Position above verb coin
                        labelX = this.verbCoin.x;
                        labelY = this.verbCoin.y - this.verbCoinRadius - labelOffset;
                    } else if (selectedItem && this.itemCursor && this.itemCursor.visible) {
                        // Position above item cursor
                        labelX = pointer.x + scrollX + 20;
                        labelY = pointer.y + scrollY - labelOffset;
                    } else {
                        // Position above crosshair cursor
                        labelX = pointer.x + scrollX;
                        labelY = pointer.y + scrollY - labelOffset;
                    }

                    // Keep label on screen
                    const halfWidth = this.hotspotLabel.width / 2 || 100;
                    labelX = Phaser.Math.Clamp(labelX, scrollX + halfWidth + 10, scrollX + width - halfWidth - 10);
                    labelY = Math.max(labelY, scrollY + 30);

                    this.hotspotLabel.setPosition(labelX, labelY);
                }

                // Continuous running
                if (this.isRunningHold && pointer.isDown && (Date.now() - this.runningHoldStartTime) > 150) {
                    if (!this.dialogActive) {
                        const targetX = pointer.x + scrollX;
                        let targetY = pointer.y + scrollY;

                        const minY = height * this.walkableArea.minY;
                        const maxY = height * this.walkableArea.maxY;
                        targetY = Phaser.Math.Clamp(targetY, minY, maxY);

                        const dx = targetX - this.player.x;
                        const dy = targetY - this.player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 5) {
                            if (this.walkTween) { this.walkTween.stop(); this.walkTween = null; }

                            const speed = 500;
                            const delta = this.game.loop.delta / 1000;
                            const moveSpeed = speed * delta;
                            const moveX = (dx / dist) * Math.min(moveSpeed, dist);
                            const moveY = (dy / dist) * Math.min(moveSpeed, dist);

                            this.player.x += moveX;
                            this.player.y += moveY;

                            if (dx < -1) this.player.setScale(-1, 1);
                            else if (dx > 1) this.player.setScale(1, 1);

                            this.player.setDepth(100 + this.player.y);

                            if (this.worldWidth > this.screenWidth) {
                                this.cameras.main.scrollX = Phaser.Math.Clamp(
                                    this.player.x - this.screenWidth / 2,
                                    0,
                                    this.worldWidth - this.screenWidth
                                );
                            }

                            if (!this.isWalking) {
                                this.isWalking = true;
                                this.startWalkAnimation(true);
                            }
                        }
                    }
                }
            }
        }

        // ============================================================================
        // GAME SCENE - House Interior (extends BaseScene)
        // Only contains room-specific content: background, hotspots, lighting
        // ============================================================================
        class GameScene extends BaseScene {
            constructor() {
                super({ key: 'GameScene' });
                this.worldWidth = 2400;
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.62, maxY: 0.88 };
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                return [
                    {
                        x: 50, y: height * 0.40, w: 80, h: height * 0.35,
                        interactX: 120, interactY: height * 0.72,
                        name: 'Front Door',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "The front door. Fresh air awaits on the other side.",
                        useResponse: "TRANSITION_TO_GARDEN",
                        talkResponse: "You're looking very door-able today."
                    },
                    {
                        x: 175, y: height * 0.22, w: 150, h: height * 0.25,
                        interactX: 175, interactY: height * 0.65,
                        name: 'Window',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Look through', talkVerb: 'Talk to' },
                        lookResponse: "A grimy window. I can barely see the moon through all that dirt.",
                        useResponse: "Painted shut. So much for my dramatic escape.",
                        talkResponse: "Hey window, how's it hanging? ...Tough crowd."
                    },
                    {
                        x: 410, y: height * 0.35, w: 120, h: height * 0.35,
                        interactX: 410, interactY: height * 0.70,
                        name: 'Bookshelf',
                        verbLabels: { actionVerb: 'Search', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Dusty old books. 'Advanced Lock Picking'... 'Treasure Hunting for Dummies'... interesting collection.",
                        useResponse: "I pull a book and... nothing happens. Not every bookshelf hides a secret passage, I guess.",
                        talkResponse: "Any of you books know the way out? No? Didn't think so."
                    },
                    {
                        x: 610, y: height * 0.72, w: 120, h: height * 0.15,
                        interactX: 500, interactY: height * 0.75,
                        name: 'Chest',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Ooh, a treasure chest! With a big golden lock on it.",
                        useResponse: "It's locked. Of course it is. I need a key.",
                        talkResponse: "Open sesame! ...No? Worth a shot."
                    },
                    {
                        x: 780, y: height * 0.35, w: 100, h: height * 0.40,
                        interactX: 720, interactY: height * 0.72,
                        name: 'Stairs to Attic',
                        verbLabels: { actionVerb: 'Climb', lookVerb: 'Look up', talkVerb: 'Call out' },
                        lookResponse: "A narrow staircase leading up to what looks like an attic. There's a faint blue glow coming from up there. And... is that television noise?",
                        useResponse: "TRANSITION_TO_ATTIC",
                        talkResponse: "Hello? Anyone up there? ...I hear what sounds like a soap opera. Weird."
                    },
                    {
                        x: 1000, y: height * 0.20, w: 200, h: height * 0.28,
                        interactX: 1000, interactY: height * 0.65,
                        name: 'Painting',
                        verbLabels: { actionVerb: 'Move', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A majestic mountain landscape. Either a masterpiece or really good hotel art.",
                        useResponse: "Wait, there's something behind the frame... A key!",
                        talkResponse: "Nice peaks. Very... mountainous."
                    },
                    {
                        x: 1290, y: height * 0.45, w: 180, h: height * 0.25,
                        interactX: 1290, interactY: height * 0.72,
                        name: 'Fireplace',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Look at', talkVerb: 'Talk to' },
                        lookResponse: "A cozy fireplace. The flames dance invitingly, but I'm not THAT cold.",
                        useResponse: "I'm not sticking my hand in there. I need these fingers for pointing at things!",
                        talkResponse: "Crackle crackle to you too, fire."
                    },
                    {
                        x: 1150, y: height * 0.77, w: 300, h: height * 0.12,
                        interactX: 1150, interactY: height * 0.75,
                        name: 'Rug',
                        verbLabels: { actionVerb: 'Lift', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A fancy Persian rug. Probably worth more than everything I own.",
                        useResponse: "I lift the corner and... just dusty floor. How disappointing.",
                        talkResponse: "You really tie the room together, you know that?"
                    },
                    {
                        x: 1550, y: height * 0.40, w: 100, h: height * 0.35,
                        interactX: 1480, interactY: height * 0.72,
                        name: 'Steel Door',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A heavy steel door with strange symbols etched into it. Definitely not original to the house.",
                        useResponse: "TRANSITION_TO_LABORATORY",
                        talkResponse: "What secrets are you hiding? ...The strong, silent type, I see."
                    },
                    {
                        x: 1840, y: height * 0.50, w: 280, h: height * 0.15,
                        interactX: 1700, interactY: height * 0.72,
                        name: 'Desk',
                        verbLabels: { actionVerb: 'Search', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "An oak desk with a journal on it. Looks important.",
                        useResponse: "The journal says 'the treasure is in the chest.' Very helpful, mysterious journal writer.",
                        talkResponse: "Hey desk, seen anything suspicious? No? Keeping your secrets, I see."
                    },
                    {
                        x: 2140, y: height * 0.35, w: 80, h: height * 0.35,
                        interactX: 2140, interactY: height * 0.72,
                        name: 'Grandfather Clock',
                        verbLabels: { actionVerb: 'Wind', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A stately grandfather clock. It's always 10:10 in here, apparently.",
                        useResponse: "I try winding it but... nothing. Time stands still in this place.",
                        talkResponse: "Tick tock, old timer. Got any secrets to share?"
                    },
                    {
                        x: 2310, y: height * 0.35, w: 120, h: height * 0.35,
                        interactX: 2200, interactY: height * 0.72,
                        name: 'Back Door',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A glass-paned door leading to the backyard. I can see some kind of glow coming from over the fence.",
                        useResponse: "TRANSITION_TO_BACKYARD",
                        talkResponse: "Take me to the great outdoors! ...Well, the small outdoors, anyway."
                    },
                    {
                        x: 2070, y: height * 0.60, w: 60, h: height * 0.20,
                        interactX: 2070, interactY: height * 0.75,
                        name: 'Potted Plant',
                        verbLabels: { actionVerb: 'Search', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A leafy potted plant. Still alive somehow, despite the neglect.",
                        useResponse: "I dig around in the soil and... just dirt. And now dirty hands. Great.",
                        talkResponse: "Hey there, little guy. Photosynthesizing hard?"
                    }
                ];
            }

            preload() {
                this.load.on('loaderror', (file) => console.log('Failed to load:', file.key));
                this.load.audio('bgMusic', './background-music.mp3');
                this.load.audio('pickupSound', './pickup.mp3');
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup for wide room
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - warm interior ambient
                this.lights.enable();
                this.lights.setAmbientColor(0x8a7a7a); // Brighter ambient for better visibility

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Dynamic elements
                this.chestContainer = this.add.container(0, 0).setDepth(50);
                this.drawChest(height, this.getFlag('chest_unlocked'));

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 400;
                if (spawnPoint === 'left') spawnX = 100;
                else if (spawnPoint === 'right') spawnX = this.worldWidth - 100;
                else if (spawnPoint === 'from_lab') spawnX = 1480;
                else if (spawnPoint === 'from_backyard') spawnX = 2200;
                else if (spawnPoint === 'from_attic') spawnX = 720;

                this.createPlayer(spawnX, height * 0.75);

                // Center camera on player
                this.cameras.main.scrollX = Phaser.Math.Clamp(
                    spawnX - this.screenWidth / 2, 0, this.worldWidth - this.screenWidth
                );

                // Play background music
                if (this.cache.audio.exists('bgMusic') && !this.sound.get('bgMusic')) {
                    this.bgMusic = this.sound.add('bgMusic', { loop: true, volume: 0.5 });
                    this.bgMusic.play();
                }

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('house_interior')) {
                    state.visitedRooms.push('house_interior');
                    this.setGameState(state);
                    this.showDialog("Great, another dusty old room. Let's see what's in here.");
                }
            }

            // Room-specific background - LucasArts MI1/MI2 style with Victorian New England aesthetic
            drawRoom(worldWidth, height) {
                if (this.textures.exists('roomBackground')) {
                    this.textures.remove('roomBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Color palette - rich Victorian tones with LucasArts depth
                const WALL_DARK = 0x1a1428;
                const WALL_MID = 0x2a2448;
                const WALL_LIGHT = 0x3a3458;
                const WALL_ACCENT = 0x4a4468;
                const WOOD_DARK = 0x2a1a0a;
                const WOOD_MID = 0x4a3018;
                const WOOD_LIGHT = 0x5a4028;
                const WOOD_HIGHLIGHT = 0x6a5038;
                const FLOOR_DARK = 0x3a2818;
                const FLOOR_MID = 0x4a3828;
                const FLOOR_LIGHT = 0x5a4838;
                const MOLDING_DARK = 0x3a2a1a;
                const MOLDING_LIGHT = 0x6a5a4a;
                const GOLD = 0xc4a035;
                const GOLD_DARK = 0x8a7025;
                const BRASS = 0xb08030;

                const floorY = height * 0.72;

                // === BACK WALL with damask pattern ===
                g.fillStyle(WALL_DARK);
                g.fillRect(0, 0, worldWidth, floorY);
                g.fillStyle(WALL_MID);
                g.fillRect(0, height * 0.08, worldWidth, floorY - height * 0.08);

                // Damask wallpaper pattern with dithering
                for (let px = 0; px < worldWidth; px += 4) {
                    for (let py = 20; py < floorY - 120; py += 4) {
                        const patternX = (px % 80);
                        const patternY = (py % 60);
                        const inDiamond = Math.abs(patternX - 40) + Math.abs(patternY - 30) < 25;
                        if (inDiamond && ((px + py) % 8 === 0)) {
                            g.fillStyle(WALL_ACCENT);
                            g.fillRect(px, py, 3, 3);
                        }
                    }
                }

                // === CROWN MOLDING ===
                g.fillStyle(MOLDING_LIGHT);
                g.fillRect(0, 0, worldWidth, 18);
                g.fillStyle(MOLDING_DARK);
                g.fillRect(0, 18, worldWidth, 6);
                for (let x = 0; x < worldWidth; x += 20) {
                    g.fillStyle(MOLDING_LIGHT);
                    g.fillRect(x, 12, 12, 8);
                    if (x % 40 === 0) {
                        g.fillStyle(MOLDING_DARK);
                        g.fillRect(x + 10, 14, 2, 6);
                    }
                }

                // === WAINSCOTING ===
                const wainscotTop = floorY - 130;
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(0, wainscotTop - 8, worldWidth, 4);
                g.fillStyle(WOOD_MID);
                g.fillRect(0, wainscotTop - 4, worldWidth, 4);
                g.fillStyle(WOOD_DARK);
                g.fillRect(0, wainscotTop, worldWidth, 2);
                g.fillStyle(WOOD_MID);
                g.fillRect(0, wainscotTop, worldWidth, 130);

                // Wainscot panels
                for (let px = 30; px < worldWidth - 30; px += 140) {
                    g.fillStyle(WOOD_DARK);
                    g.fillRect(px, wainscotTop + 15, 110, 95);
                    g.fillStyle(WOOD_MID);
                    g.fillRect(px + 4, wainscotTop + 19, 102, 87);
                    for (let gy = wainscotTop + 22; gy < wainscotTop + 100; gy += 6) {
                        if ((px + gy) % 12 === 0) {
                            g.fillStyle(WOOD_LIGHT);
                            g.fillRect(px + 8, gy, 94, 2);
                        }
                    }
                    g.fillStyle(WOOD_HIGHLIGHT);
                    g.fillRect(px + 4, wainscotTop + 19, 102, 2);
                    g.fillRect(px + 4, wainscotTop + 19, 2, 87);
                }

                // Baseboard
                g.fillStyle(WOOD_DARK);
                g.fillRect(0, floorY - 12, worldWidth, 12);
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(0, floorY - 12, worldWidth, 2);

                // === FLOOR (simple parallel boards) ===
                g.fillStyle(FLOOR_DARK);
                g.fillRect(0, floorY, worldWidth, height - floorY);

                // Simple parallel floorboard lines
                g.lineStyle(2, WOOD_DARK, 0.6);
                for (let x = 0; x < worldWidth; x += 80) {
                    g.moveTo(x, floorY);
                    g.lineTo(x, height);
                }
                g.strokePath();

                // Horizontal plank lines
                for (let y = floorY + 25; y < height; y += 25) {
                    g.lineStyle(1, FLOOR_LIGHT, 0.4);
                    g.moveTo(0, y);
                    g.lineTo(worldWidth, y);
                    g.strokePath();
                }

                // Floor dithering for wood texture
                for (let px = 0; px < worldWidth; px += 8) {
                    for (let py = floorY; py < height; py += 8) {
                        if ((px + py) % 24 === 0) {
                            g.fillStyle(FLOOR_LIGHT);
                            g.fillRect(px, py, 3, 2);
                        }
                    }
                }

                // === FRONT DOOR (hotspot x:50) ===
                const doorX = 20, doorY = 70, doorW = 90, doorH = floorY - 70;
                g.fillStyle(WOOD_DARK);
                g.fillRect(doorX - 12, doorY - 20, doorW + 24, doorH + 20);
                // Transom
                g.fillStyle(0x0a1525);
                g.fillRect(doorX, doorY - 15, doorW, 20);
                g.fillStyle(WOOD_MID);
                g.fillRect(doorX + doorW/3, doorY - 15, 3, 20);
                g.fillRect(doorX + doorW*2/3, doorY - 15, 3, 20);
                // Door body
                g.fillStyle(WOOD_MID);
                g.fillRect(doorX, doorY + 8, doorW, doorH - 8);
                // Four panels
                const panelW = 35, panelH = 70;
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 2; col++) {
                        const px = doorX + 8 + col * 42;
                        const py = doorY + 20 + row * 85;
                        g.fillStyle(WOOD_DARK);
                        g.fillRect(px, py, panelW, panelH);
                        g.fillStyle(WOOD_LIGHT);
                        g.fillRect(px + 3, py + 3, panelW - 6, panelH - 6);
                    }
                }
                // Hardware
                g.fillStyle(BRASS);
                g.fillRect(doorX + doorW - 20, doorY + doorH/2, 8, 35);
                g.fillStyle(GOLD);
                g.fillCircle(doorX + doorW - 16, doorY + doorH/2 + 18, 6);

                // === WINDOW (hotspot x:175, extended lower to wainscot) ===
                const winX = 160, winY = 50, winW = 130, winH = wainscotTop - 60;
                // Window recess
                g.fillStyle(WOOD_DARK);
                g.fillRect(winX - 10, winY - 10, winW + 20, winH + 20);
                // Night sky
                g.fillStyle(0x0a0a20);
                g.fillRect(winX, winY, winW, winH);
                // Moon glow
                for (let r = 50; r > 0; r -= 5) {
                    g.fillStyle(r > 30 ? 0x1a1a40 : r > 15 ? 0x2a2a60 : 0x4a4a80);
                    g.fillCircle(winX + winW - 35, winY + 45, r);
                }
                g.fillStyle(0xe8e8d0);
                g.fillCircle(winX + winW - 35, winY + 45, 16);
                // Window frame (6 panes)
                g.fillStyle(WOOD_MID);
                g.fillRect(winX + winW/2 - 3, winY, 6, winH);
                g.fillRect(winX, winY + winH/3, winW, 6);
                g.fillRect(winX, winY + winH*2/3, winW, 6);
                // Frame border
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(winX - 6, winY - 6, winW + 12, 5);
                g.fillRect(winX - 6, winY + winH + 1, winW + 12, 5);
                g.fillRect(winX - 6, winY - 6, 5, winH + 12);
                g.fillRect(winX + winW + 1, winY - 6, 5, winH + 12);
                // Velvet curtains (extending to wainscot)
                const curtainColor1 = 0x4a0a1a;
                const curtainColor2 = 0x6a1a2a;
                for (let cy = winY - 15; cy < wainscotTop - 5; cy += 3) {
                    const fold = Math.sin(cy * 0.07) * 7;
                    g.fillStyle((cy % 6 < 3) ? curtainColor1 : curtainColor2);
                    g.fillRect(winX - 30 + fold, cy, 25, 3);
                    g.fillRect(winX + winW + 5 - fold, cy, 25, 3);
                }
                // Curtain rod
                g.fillStyle(BRASS);
                g.fillRect(winX - 40, winY - 20, winW + 80, 5);
                g.fillStyle(GOLD);
                g.fillCircle(winX - 40, winY - 18, 7);
                g.fillCircle(winX + winW + 40, winY - 18, 7);

                // === BOOKSHELF (hotspot x:410) ===
                const shelfX = 350, shelfY = 80, shelfW = 140, shelfH = floorY - 90;
                g.fillStyle(WOOD_DARK);
                g.fillRect(shelfX, shelfY, shelfW, shelfH);
                g.fillStyle(WOOD_MID);
                g.fillRect(shelfX + 5, shelfY + 5, shelfW - 10, shelfH - 10);
                // Pediment
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillTriangle(shelfX + shelfW/2, shelfY - 12, shelfX + 15, shelfY + 3, shelfX + shelfW - 15, shelfY + 3);
                // Shelves with books
                const bookColors = [0x6a1010, 0x104a10, 0x10106a, 0x4a104a, 0x4a3010, 0x103a4a];
                for (let s = 0; s < 5; s++) {
                    const sy = shelfY + 15 + s * (shelfH - 25) / 5;
                    g.fillStyle(WOOD_LIGHT);
                    g.fillRect(shelfX + 8, sy + 40, shelfW - 16, 5);
                    let bx = shelfX + 12;
                    while (bx < shelfX + shelfW - 18) {
                        const bookW = 7 + (bx * s) % 6;
                        const bookH = 28 + (bx + s) % 12;
                        g.fillStyle(bookColors[(bx + s) % bookColors.length]);
                        g.fillRect(bx, sy + 43 - bookH, bookW, bookH);
                        bx += bookW + 2;
                    }
                }

                // === STAIRWELL TO ATTIC (hotspot x:780) ===
                const stairX = 720, stairY = 50, stairW = 120, stairH = floorY - 50;
                // Dark stairwell opening
                g.fillStyle(0x0a0808);
                g.fillRect(stairX, stairY, stairW, stairH);
                // Wooden frame
                g.fillStyle(WOOD_DARK);
                g.fillRect(stairX - 8, stairY - 8, 10, stairH + 16);
                g.fillRect(stairX + stairW - 2, stairY - 8, 10, stairH + 16);
                g.fillRect(stairX - 8, stairY - 12, stairW + 16, 12);
                // Visible stairs going up into darkness
                for (let step = 0; step < 6; step++) {
                    const stepY = floorY - 25 - step * 35;
                    const stepX = stairX + 10 + step * 8;
                    const stepW = stairW - 20 - step * 12;
                    if (stepY > stairY + 20) {
                        // Step top
                        g.fillStyle(WOOD_MID);
                        g.fillRect(stepX, stepY - 6, stepW, 6);
                        // Step front
                        g.fillStyle(WOOD_DARK);
                        g.fillRect(stepX, stepY, stepW, 18);
                    }
                }
                // Blue TV glow from above (subtle hint)
                g.fillStyle(0x2a3a4a);
                g.fillRect(stairX + 20, stairY + 10, stairW - 40, 40);
                for (let gx = stairX + 25; gx < stairX + stairW - 25; gx += 6) {
                    for (let gy = stairY + 15; gy < stairY + 45; gy += 6) {
                        if ((gx + gy) % 12 === 0) {
                            g.fillStyle(0x3a5a7a);
                            g.fillRect(gx, gy, 3, 3);
                        }
                    }
                }
                // Railing
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(stairX + stairW - 12, stairY + 30, 6, stairH - 40);
                g.fillStyle(BRASS);
                g.fillCircle(stairX + stairW - 9, stairY + 28, 6);

                // === PAINTING (hotspot x:1000, standalone on wall) ===
                const paintX = 950, paintY = 60, paintW = 160, paintH = 110;
                // Gold frame
                g.fillStyle(GOLD_DARK);
                g.fillRect(paintX - 10, paintY - 10, paintW + 20, paintH + 20);
                g.fillStyle(GOLD);
                g.fillRect(paintX - 6, paintY - 6, paintW + 12, paintH + 12);
                g.fillStyle(GOLD_DARK);
                g.fillRect(paintX - 2, paintY - 2, paintW + 4, paintH + 4);
                // Canvas - landscape
                g.fillStyle(0x87ceeb);
                g.fillRect(paintX, paintY, paintW, paintH * 0.6);
                g.fillStyle(0x228b22);
                g.fillRect(paintX, paintY + paintH * 0.5, paintW, paintH * 0.5);
                // Mountains
                g.fillStyle(0x4a4a6a);
                g.fillTriangle(paintX + 40, paintY + 25, paintX + 10, paintY + paintH * 0.6, paintX + 70, paintY + paintH * 0.6);
                g.fillTriangle(paintX + 100, paintY + 20, paintX + 60, paintY + paintH * 0.6, paintX + 140, paintY + paintH * 0.6);
                // Snow caps
                g.fillStyle(0xffffff);
                g.fillTriangle(paintX + 40, paintY + 25, paintX + 30, paintY + 40, paintX + 50, paintY + 40);
                g.fillTriangle(paintX + 100, paintY + 20, paintX + 88, paintY + 38, paintX + 112, paintY + 38);

                // === FIREPLACE (hotspot x:1290, lower mantle) ===
                const fpX = 1200, fpY = 160, fpW = 180, fpH = floorY - 160;
                // Stone surround
                g.fillStyle(0x4a4a4a);
                g.fillRect(fpX, fpY, fpW, fpH);
                // Stone texture
                for (let sx = fpX; sx < fpX + fpW; sx += 10) {
                    for (let sy = fpY; sy < fpY + fpH; sy += 10) {
                        if ((sx + sy) % 20 === 0) {
                            g.fillStyle(0x5a5a5a);
                            g.fillRect(sx, sy, 7, 7);
                        }
                    }
                }
                // Firebox
                g.fillStyle(0x0a0a0a);
                g.fillRect(fpX + 25, fpY + 50, fpW - 50, fpH - 60);
                // Grate
                g.fillStyle(0x2a2a2a);
                g.fillRect(fpX + 35, fpY + fpH - 25, fpW - 70, 6);
                // Logs
                g.fillStyle(0x3a2010);
                g.fillRect(fpX + 45, fpY + fpH - 45, 40, 16);
                g.fillRect(fpX + 90, fpY + fpH - 40, 35, 12);
                // Flames
                g.fillStyle(0xff2200);
                g.fillTriangle(fpX + 70, fpY + fpH - 80, fpX + 50, fpY + fpH - 40, fpX + 90, fpY + fpH - 40);
                g.fillTriangle(fpX + 110, fpY + fpH - 75, fpX + 90, fpY + fpH - 40, fpX + 130, fpY + fpH - 40);
                g.fillStyle(0xff6600);
                g.fillTriangle(fpX + 80, fpY + fpH - 65, fpX + 60, fpY + fpH - 40, fpX + 100, fpY + fpH - 40);
                g.fillStyle(0xffaa00);
                g.fillTriangle(fpX + 90, fpY + fpH - 55, fpX + 75, fpY + fpH - 40, fpX + 105, fpY + fpH - 40);
                g.fillStyle(0xffdd44);
                g.fillTriangle(fpX + 90, fpY + fpH - 48, fpX + 82, fpY + fpH - 40, fpX + 98, fpY + fpH - 40);
                // Mantle (lower position)
                g.fillStyle(WOOD_DARK);
                g.fillRect(fpX - 12, fpY - 12, fpW + 24, 20);
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(fpX - 12, fpY - 12, fpW + 24, 5);
                // Corbels
                g.fillStyle(WOOD_MID);
                g.fillRect(fpX - 8, fpY + 5, 16, 45);
                g.fillRect(fpX + fpW - 8, fpY + 5, 16, 45);

                // === RUG (hotspot x:1150) ===
                const rugX = 1050, rugY = floorY + 12, rugW = 320, rugH = height - floorY - 25;
                g.fillStyle(0x6a1515);
                g.fillRoundedRect(rugX, rugY, rugW, rugH, 4);
                g.fillStyle(GOLD_DARK);
                g.fillRoundedRect(rugX + 8, rugY + 5, rugW - 16, rugH - 10, 3);
                g.fillStyle(0x4a0a0a);
                g.fillRoundedRect(rugX + 18, rugY + 12, rugW - 36, rugH - 24, 2);
                // Pattern
                for (let rx = rugX + 25; rx < rugX + rugW - 25; rx += 12) {
                    for (let ry = rugY + 16; ry < rugY + rugH - 16; ry += 12) {
                        if ((rx + ry) % 36 === 0) {
                            g.fillStyle(GOLD);
                            g.fillRect(rx, ry, 4, 4);
                        }
                    }
                }
                // Medallion
                g.fillStyle(GOLD_DARK);
                g.fillCircle(rugX + rugW/2, rugY + rugH/2, 30);
                g.fillStyle(0x6a1515);
                g.fillCircle(rugX + rugW/2, rugY + rugH/2, 22);
                g.fillStyle(GOLD);
                g.fillCircle(rugX + rugW/2, rugY + rugH/2, 6);

                // === STEEL LAB DOOR (hotspot x:1550) ===
                const labX = 1500, labY = 80, labW = 100, labH = floorY - 80;
                g.fillStyle(0x3a3a3a);
                g.fillRect(labX - 8, labY - 8, labW + 16, labH + 8);
                g.fillStyle(0x5a5a5a);
                g.fillRect(labX, labY, labW, labH);
                // Texture
                for (let dx = labX; dx < labX + labW; dx += 14) {
                    for (let dy = labY; dy < labY + labH; dy += 14) {
                        if ((dx + dy) % 28 === 0) {
                            g.fillStyle(0x6a6a6a);
                            g.fillRect(dx, dy, 10, 10);
                        }
                    }
                }
                // Rivets
                g.fillStyle(0x707070);
                [[12, 15], [labW-12, 15], [12, labH-15], [labW-12, labH-15]].forEach(([rx, ry]) => {
                    g.fillCircle(labX + rx, labY + ry, 5);
                });
                // Symbol
                g.lineStyle(3, 0x30a0a0, 0.9);
                g.strokeCircle(labX + labW/2, labY + labH/2 - 15, 25);
                g.moveTo(labX + labW/2, labY + labH/2 - 40);
                g.lineTo(labX + labW/2, labY + labH/2 + 10);
                g.moveTo(labX + labW/2 - 25, labY + labH/2 - 15);
                g.lineTo(labX + labW/2 + 25, labY + labH/2 - 15);
                g.strokePath();
                // Handle
                g.fillStyle(0x505050);
                g.fillRect(labX + labW - 25, labY + labH/2 + 15, 15, 40);

                // === DESK (hotspot x:1840) ===
                const deskX = 1750, deskY = floorY - 130, deskW = 180, deskH = 130;
                // Legs
                g.fillStyle(WOOD_DARK);
                g.fillRect(deskX + 12, deskY + 60, 16, 70);
                g.fillRect(deskX + deskW - 28, deskY + 60, 16, 70);
                // Body
                g.fillStyle(WOOD_MID);
                g.fillRect(deskX, deskY + 25, deskW, 40);
                // Desktop
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(deskX - 5, deskY + 8, deskW + 10, 6);
                // Leather surface
                g.fillStyle(0x2a4a2a);
                g.fillRect(deskX + 5, deskY + 14, deskW - 10, 14);
                // Drawers
                g.fillStyle(WOOD_DARK);
                g.fillRect(deskX + 15, deskY + 32, 60, 28);
                g.fillRect(deskX + deskW - 75, deskY + 32, 60, 28);
                g.fillStyle(WOOD_LIGHT);
                g.fillRect(deskX + 18, deskY + 35, 54, 22);
                g.fillRect(deskX + deskW - 72, deskY + 35, 54, 22);
                // Pulls
                g.fillStyle(BRASS);
                g.fillCircle(deskX + 45, deskY + 46, 4);
                g.fillCircle(deskX + deskW - 45, deskY + 46, 4);
                // Papers
                g.fillStyle(0xf5f0e0);
                g.fillRect(deskX + 50, deskY - 5, 45, 30);
                // Inkwell
                g.fillStyle(0x1a1a1a);
                g.fillRect(deskX + deskW - 40, deskY - 2, 18, 12);

                // === CLOCK (hotspot x:2140) ===
                const clockX = 2100, clockY = 45, clockW = 65, clockH = floorY - 50;
                g.fillStyle(WOOD_DARK);
                g.fillRect(clockX, clockY, clockW, clockH);
                // Hood
                g.fillStyle(WOOD_MID);
                g.fillRect(clockX - 4, clockY, clockW + 8, 75);
                // Pediment
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillTriangle(clockX + clockW/2, clockY - 12, clockX - 4, clockY + 4, clockX + clockW + 4, clockY + 4);
                // Finials
                g.fillStyle(BRASS);
                g.fillCircle(clockX + 4, clockY - 3, 5);
                g.fillCircle(clockX + clockW/2, clockY - 15, 7);
                g.fillCircle(clockX + clockW - 4, clockY - 3, 5);
                // Face
                g.fillStyle(GOLD_DARK);
                g.fillCircle(clockX + clockW/2, clockY + 42, 25);
                g.fillStyle(0xfff8e0);
                g.fillCircle(clockX + clockW/2, clockY + 42, 21);
                // Hands
                g.lineStyle(2, 0x1a1a1a, 1);
                g.moveTo(clockX + clockW/2, clockY + 42);
                g.lineTo(clockX + clockW/2, clockY + 28);
                g.moveTo(clockX + clockW/2, clockY + 42);
                g.lineTo(clockX + clockW/2 + 10, clockY + 47);
                g.strokePath();
                // Trunk
                g.fillStyle(WOOD_MID);
                g.fillRect(clockX + 8, clockY + 80, clockW - 16, clockH - 110);
                // Pendulum window
                g.fillStyle(0x0a0a15);
                g.fillRect(clockX + 14, clockY + 90, clockW - 28, clockH - 140);
                // Pendulum
                g.fillStyle(BRASS);
                g.fillRect(clockX + clockW/2 - 2, clockY + 95, 4, clockH - 165);
                g.fillStyle(GOLD);
                g.fillCircle(clockX + clockW/2, clockY + clockH - 80, 15);
                // Base
                g.fillStyle(WOOD_HIGHLIGHT);
                g.fillRect(clockX - 6, clockY + clockH - 30, clockW + 12, 30);

                // === PLANT (hotspot x:2070) ===
                const plantX = 2040, plantY = floorY - 80;
                g.fillStyle(0x8a4a2a);
                g.fillRect(plantX, plantY + 45, 45, 35);
                g.fillStyle(0x9a5a3a);
                g.fillRect(plantX - 4, plantY + 40, 53, 8);
                g.fillStyle(0x2a1a0a);
                g.fillRect(plantX + 6, plantY + 43, 33, 6);
                // Fern
                const fernColors = [0x1a4a1a, 0x2a5a2a, 0x3a6a3a];
                for (let f = 0; f < 6; f++) {
                    const angle = (f - 2.5) * 0.35;
                    g.fillStyle(fernColors[f % 3]);
                    for (let i = 0; i < 10; i++) {
                        const fx = plantX + 22 + Math.sin(angle) * i * 3.5;
                        const fy = plantY + 38 - i * 5;
                        g.fillRect(fx - 2, fy, 4, 4);
                        g.fillRect(fx - 7, fy + 1, 5, 3);
                        g.fillRect(fx + 3, fy + 1, 5, 3);
                    }
                }

                // === BACK DOOR (hotspot x:2310) ===
                const bdoorX = 2260, bdoorY = 85, bdoorW = 90, bdoorH = floorY - 85;
                g.fillStyle(WOOD_DARK);
                g.fillRect(bdoorX - 8, bdoorY - 8, bdoorW + 16, bdoorH + 8);
                g.fillStyle(WOOD_MID);
                g.fillRect(bdoorX, bdoorY, bdoorW, bdoorH);
                // Glass panes (2x2)
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 2; col++) {
                        g.fillStyle(0x0a1020);
                        g.fillRect(bdoorX + 10 + col * 38, bdoorY + 15 + row * 90, 32, 75);
                        if ((col + row) % 2 === 0) {
                            g.fillStyle(0xffffff);
                            g.fillRect(bdoorX + 20 + col * 38, bdoorY + 35 + row * 60, 2, 2);
                        }
                    }
                }
                // Warm glow
                g.fillStyle(0x3a3020);
                g.fillRect(bdoorX + 15, bdoorY + 120, 25, 30);
                // Handle
                g.fillStyle(BRASS);
                g.fillCircle(bdoorX + bdoorW - 15, bdoorY + bdoorH/2, 7);

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('roomBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'roomBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            // Room-specific chest (hotspot x:610)
            drawChest(height, isOpen) {
                this.chestContainer.removeAll(true);
                const chestX = 600, chestW = 120;

                const createBlock = (x, y, w, h, color) => {
                    const gfx = this.add.graphics();
                    gfx.fillStyle(color, 1);
                    gfx.fillRect(x, y, w, h);
                    gfx.setPipeline('Light2D');
                    return gfx;
                };

                if (isOpen) {
                    this.chestContainer.add(createBlock(chestX, height * 0.65, chestW, height * 0.15, 0x654321));
                    this.chestContainer.add(createBlock(chestX + 10, height * 0.68, chestW - 20, height * 0.10, 0x4a2d1e));
                    this.chestContainer.add(createBlock(chestX, height * 0.62, chestW, height * 0.06, 0x654321));
                    this.chestContainer.add(createBlock(chestX + 8, height * 0.63, chestW - 16, height * 0.04, 0x5c3d2e));

                    if (!this.getFlag('chest_looted')) {
                        if (!this.textures.exists('rubyGem')) {
                            const rubyRt = this.add.renderTexture(0, 0, 24, 24);
                            const rubyG = this.make.graphics({ add: false });
                            rubyG.fillStyle(0xe91e63);
                            rubyG.fillCircle(12, 12, 12);
                            rubyG.fillStyle(0xff5c8d);
                            rubyG.fillCircle(9, 10, 5);
                            rubyRt.draw(rubyG);
                            rubyG.destroy();
                            rubyRt.saveTexture('rubyGem');
                            rubyRt.destroy();
                        }
                        const ruby = this.add.sprite(chestX + chestW / 2, height * 0.72, 'rubyGem');
                        ruby.setPipeline('Light2D');
                        this.chestContainer.add(ruby);
                    }
                } else {
                    this.chestContainer.add(createBlock(chestX, height * 0.65, chestW, height * 0.15, 0x654321));
                    this.chestContainer.add(createBlock(chestX, height * 0.65, chestW, height * 0.04, 0x8b4513));
                    this.chestContainer.add(createBlock(chestX + chestW / 2 - 15, height * 0.72, 30, 18, 0xffd700));
                }
            }

            // Room-specific lighting
            createLighting(worldWidth, height) {
                // Cool moonlight through window (window center ~225) - larger radius, softer
                this.moonLight = this.lights.addLight(225, height * 0.25, 500, 0x7788bb, 0.6);
                this.moonLightSoft = this.lights.addLight(225, height * 0.30, 700, 0x556688, 0.25);

                // Main fireplace light - warm orange (fireplace center at 1290)
                this.fireplaceLight = this.lights.addLight(1290, height * 0.55, 550, 0xff8844, 1.2);
                // Secondary fireplace glow - softer, warmer
                this.fireplaceGlow = this.lights.addLight(1290, height * 0.62, 400, 0xffaa55, 0.7);
                // Tertiary ambient fire warmth - very large soft radius
                this.fireplaceAmbient = this.lights.addLight(1290, height * 0.65, 800, 0xff6633, 0.25);

                // Desk lamp - warm yellow (desk center ~1840) - larger radius
                this.deskLamp = this.lights.addLight(1840, height * 0.40, 400, 0xffee99, 0.9);
                this.deskLampSoft = this.lights.addLight(1840, height * 0.45, 600, 0xffdd77, 0.35);
                // Clock face subtle glow (clock center ~2132)
                this.clockLight = this.lights.addLight(2132, height * 0.38, 250, 0xffcc88, 0.5);

                // General room fill lights for visibility - increased
                this.fillLight1 = this.lights.addLight(500, height * 0.50, 600, 0x998877, 0.4);
                this.fillLight2 = this.lights.addLight(1900, height * 0.50, 600, 0x887766, 0.35);
                this.fillLight3 = this.lights.addLight(1200, height * 0.60, 500, 0x887777, 0.3);

                // Base intensities for animation
                this.fireplaceBaseIntensity = 1.2;
                this.fireplaceGlowBaseIntensity = 0.7;
                this.fireplaceAmbientBaseIntensity = 0.25;

                this.createLightBloom(height);
            }

            createLightBloom(height) {
                // Multi-layered fireplace bloom for soft gradual falloff (fireplace at 1290)
                // Layer 1: Core glow
                this.fireplaceBloom1 = this.add.graphics();
                this.fireplaceBloom1.fillStyle(0xff4400, 0.10);
                this.fireplaceBloom1.fillCircle(0, 0, 50);
                this.fireplaceBloom1.setPosition(1290, height * 0.60);
                this.fireplaceBloom1.setBlendMode(Phaser.BlendModes.ADD);
                this.fireplaceBloom1.setDepth(1);

                // Layer 2: Inner glow
                this.fireplaceBloom2 = this.add.graphics();
                this.fireplaceBloom2.fillStyle(0xff6600, 0.07);
                this.fireplaceBloom2.fillCircle(0, 0, 100);
                this.fireplaceBloom2.setPosition(1290, height * 0.60);
                this.fireplaceBloom2.setBlendMode(Phaser.BlendModes.ADD);
                this.fireplaceBloom2.setDepth(1);

                // Layer 3: Mid glow
                this.fireplaceBloom3 = this.add.graphics();
                this.fireplaceBloom3.fillStyle(0xff7733, 0.05);
                this.fireplaceBloom3.fillCircle(0, 0, 160);
                this.fireplaceBloom3.setPosition(1290, height * 0.60);
                this.fireplaceBloom3.setBlendMode(Phaser.BlendModes.ADD);
                this.fireplaceBloom3.setDepth(1);

                // Layer 4: Outer soft glow
                const fireplaceBloom4 = this.add.graphics();
                fireplaceBloom4.fillStyle(0xff8844, 0.03);
                fireplaceBloom4.fillCircle(0, 0, 250);
                fireplaceBloom4.setPosition(1290, height * 0.60);
                fireplaceBloom4.setBlendMode(Phaser.BlendModes.ADD);
                fireplaceBloom4.setDepth(1);

                // Layer 5: Very soft ambient warmth
                const fireplaceBloom5 = this.add.graphics();
                fireplaceBloom5.fillStyle(0xff9955, 0.02);
                fireplaceBloom5.fillCircle(0, 0, 350);
                fireplaceBloom5.setPosition(1290, height * 0.60);
                fireplaceBloom5.setBlendMode(Phaser.BlendModes.ADD);
                fireplaceBloom5.setDepth(1);

                // Moonlight bloom - cool blue, multi-layered soft (window center at 225)
                const moonBloom1 = this.add.graphics();
                moonBloom1.fillStyle(0x7799dd, 0.08);
                moonBloom1.fillCircle(0, 0, 80);
                moonBloom1.setPosition(225, height * 0.28);
                moonBloom1.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom1.setDepth(1);

                const moonBloom2 = this.add.graphics();
                moonBloom2.fillStyle(0x6688cc, 0.06);
                moonBloom2.fillCircle(0, 0, 140);
                moonBloom2.setPosition(225, height * 0.28);
                moonBloom2.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom2.setDepth(1);

                const moonBloom3 = this.add.graphics();
                moonBloom3.fillStyle(0x5577aa, 0.04);
                moonBloom3.fillCircle(0, 0, 220);
                moonBloom3.setPosition(225, height * 0.28);
                moonBloom3.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom3.setDepth(1);

                const moonBloom4 = this.add.graphics();
                moonBloom4.fillStyle(0x446699, 0.02);
                moonBloom4.fillCircle(0, 0, 320);
                moonBloom4.setPosition(225, height * 0.28);
                moonBloom4.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom4.setDepth(1);

                // Desk lamp bloom - multi-layered soft (desk center at 1840)
                const deskBloom1 = this.add.graphics();
                deskBloom1.fillStyle(0xffee88, 0.08);
                deskBloom1.fillCircle(0, 0, 60);
                deskBloom1.setPosition(1840, height * 0.42);
                deskBloom1.setBlendMode(Phaser.BlendModes.ADD);
                deskBloom1.setDepth(1);

                const deskBloom2 = this.add.graphics();
                deskBloom2.fillStyle(0xffdd77, 0.06);
                deskBloom2.fillCircle(0, 0, 110);
                deskBloom2.setPosition(1840, height * 0.42);
                deskBloom2.setBlendMode(Phaser.BlendModes.ADD);
                deskBloom2.setDepth(1);

                const deskBloom3 = this.add.graphics();
                deskBloom3.fillStyle(0xffcc66, 0.04);
                deskBloom3.fillCircle(0, 0, 180);
                deskBloom3.setPosition(1840, height * 0.42);
                deskBloom3.setBlendMode(Phaser.BlendModes.ADD);
                deskBloom3.setDepth(1);

                const deskBloom4 = this.add.graphics();
                deskBloom4.fillStyle(0xffbb55, 0.02);
                deskBloom4.fillCircle(0, 0, 260);
                deskBloom4.setPosition(1840, height * 0.42);
                deskBloom4.setBlendMode(Phaser.BlendModes.ADD);
                deskBloom4.setDepth(1);
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                if (action === 'Look At') {
                    if (hotspot.name === 'Chest') {
                        if (this.getFlag('chest_looted')) {
                            this.showDialog("Empty now. I already grabbed everything.");
                        } else if (this.getFlag('chest_unlocked')) {
                            this.showDialog("It's open! And there's something sparkly inside...");
                        } else {
                            this.showDialog(hotspot.lookResponse);
                        }
                    } else if (hotspot.name === 'Painting') {
                        if (this.getFlag('key_found')) {
                            this.showDialog("A majestic mountain landscape. The frame's a bit crooked now.");
                        } else {
                            this.showDialog(hotspot.lookResponse);
                        }
                    } else {
                        this.showDialog(hotspot.lookResponse);
                    }
                } else if (action === 'Use') {
                    if (hotspot.name === 'Front Door') {
                        this.transitionToScene('GardenScene', 'from_house');
                    } else if (hotspot.name === 'Steel Door') {
                        this.transitionToScene('LaboratoryScene', 'from_house');
                    } else if (hotspot.name === 'Back Door') {
                        this.transitionToScene('BackyardScene', 'from_house');
                    } else if (hotspot.name === 'Stairs to Attic') {
                        this.transitionToScene('AtticScene', 'from_house');
                    } else if (hotspot.name === 'Painting') {
                        if (!this.getFlag('key_found')) {
                            this.setFlag('key_found', true);
                            this.addToInventory({ id: 'key', name: 'Key', color: 0xffd700 });
                            this.showDialog("Wait, a key behind the painting? Classic!");
                        } else {
                            this.showDialog("Nothing else here. Just wall.");
                        }
                    } else if (hotspot.name === 'Chest') {
                        if (!this.getFlag('chest_unlocked')) {
                            this.showDialog(hotspot.useResponse);
                        } else if (!this.getFlag('chest_looted')) {
                            this.setFlag('chest_looted', true);
                            this.addToInventory({ id: 'gem', name: 'Ruby', color: 0xe91e63 });
                            this.drawChest(this.scale.height, true);
                            this.showDialog("A ruby! A big sparkly ruby! This is mine now.");
                        } else {
                            this.showDialog("Already empty. I'm thorough.");
                        }
                    } else {
                        this.showDialog(hotspot.useResponse);
                    }
                } else if (action === 'Talk To') {
                    this.showDialog(hotspot.talkResponse);
                }
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (item.id === 'key' && hotspot.name === 'Chest') {
                    if (!this.getFlag('chest_unlocked')) {
                        this.setFlag('chest_unlocked', true);
                        this.removeFromInventory('key');
                        this.deselectItem();
                        this.drawChest(this.scale.height, true);
                        this.showDialog("Click! The key fits! The chest is open!");
                    } else {
                        this.showDialog("It's already unlocked.");
                    }
                } else {
                    this.showDialog(`That doesn't work.`);
                }
            }

            update() {
                super.update();

                // Organic fireplace flicker with multiple frequencies
                if (this.fireplaceLight) {
                    const time = this.time.now * 0.001;

                    // Combine multiple sine waves for organic flicker
                    const flicker1 = Math.sin(time * 8) * 0.12;
                    const flicker2 = Math.sin(time * 13 + 0.5) * 0.08;
                    const flicker3 = Math.sin(time * 21 + 1.2) * 0.05;
                    const randomPop = Math.random() > 0.98 ? 0.15 : 0; // Occasional spark pop
                    const totalFlicker = flicker1 + flicker2 + flicker3 + randomPop;

                    // Main fireplace light intensity
                    this.fireplaceLight.intensity = this.fireplaceBaseIntensity + totalFlicker;

                    // Secondary glow follows with slight delay feel
                    const glowFlicker = Math.sin(time * 7 + 0.3) * 0.1 + Math.sin(time * 15 + 0.8) * 0.06;
                    this.fireplaceGlow.intensity = this.fireplaceGlowBaseIntensity + glowFlicker;

                    // Ambient warmth pulses slowly
                    const ambientPulse = Math.sin(time * 2) * 0.08;
                    this.fireplaceAmbient.intensity = this.fireplaceAmbientBaseIntensity + ambientPulse;

                    // Animate bloom opacity for soft glow effect
                    if (this.fireplaceBloom1) {
                        this.fireplaceBloom1.setAlpha(0.8 + totalFlicker * 0.5);
                        this.fireplaceBloom2.setAlpha(0.7 + glowFlicker * 0.4);
                    }
                }
            }
        }

        // ============================================================================
        // GARDEN SCENE - Victorian House Exterior at Night (extends BaseScene)
        // ============================================================================
        class GardenScene extends BaseScene {
            constructor() {
                super({ key: 'GardenScene' });
                this.worldWidth = 1280;
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.70, maxY: 0.92 };
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                return [
                    {
                        x: 1050, y: height * 0.45, w: 100, h: height * 0.30,
                        interactX: 980, interactY: height * 0.75,
                        name: 'Front Door',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "The front door. Looks warmer inside than out here.",
                        useResponse: "TRANSITION_TO_HOUSE",
                        talkResponse: "Open up! ...Oh wait, I can just use you."
                    },
                    {
                        x: 180, y: height * 0.72, w: 140, h: height * 0.18,
                        interactX: 250, interactY: height * 0.80,
                        name: 'Rose Bush',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Thorny roses. Beautiful but deadly. Nature's way of saying 'look, don't touch.'",
                        useResponse: "Ouch! These thorns are vicious. Better admire from afar.",
                        talkResponse: "Hey roses. Looking sharp tonight. Literally."
                    },
                    {
                        x: 640, y: height * 0.85, w: 400, h: height * 0.10,
                        interactX: 640, interactY: height * 0.82,
                        name: 'Garden Path',
                        verbLabels: { actionVerb: 'Walk on', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A winding dirt path. It's seen better days, much like this garden.",
                        useResponse: "Walking on it now. Mission accomplished.",
                        talkResponse: "Where do you lead, mysterious path? ...To the house, apparently."
                    },
                    {
                        x: 100, y: height * 0.35, w: 200, h: height * 0.30,
                        interactX: 200, interactY: height * 0.75,
                        name: 'Dark Woods',
                        verbLabels: { actionVerb: 'Enter', lookVerb: 'Peer into', talkVerb: 'Call out to' },
                        lookResponse: "Dense, dark woods. Probably full of wolves. Or worse, squirrels with attitude.",
                        useResponse: "TRANSITION_TO_FOREST",
                        talkResponse: "Hello darkness, my old friend..."
                    },
                    {
                        x: 450, y: height * 0.65, w: 80, h: height * 0.15,
                        interactX: 450, interactY: height * 0.78,
                        name: 'Garden Statue',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A cherub statue. Its blank eyes follow me everywhere. Creepy.",
                        useResponse: "It's cemented in place. Probably for the best.",
                        talkResponse: "Any secrets to share? No? Just gonna stare? Okay then."
                    }
                ];
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup (single screen, no scroll)
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - cool moonlit exterior
                this.lights.enable();
                const isMobile = this.sys.game.device.input.touch;
                this.lights.setAmbientColor(isMobile ? 0x9a9aba : 0x7a7a9a); // Brighter on mobile

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create edge zones for scene transitions
                this.createEdgeZones(height);

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 640;
                if (spawnPoint === 'from_house') spawnX = 900;
                else if (spawnPoint === 'from_forest') spawnX = 120;
                else if (spawnPoint === 'left') spawnX = 100;

                this.createPlayer(spawnX, height * 0.80);

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('garden')) {
                    state.visitedRooms.push('garden');
                    this.setGameState(state);
                    this.showDialog("Ah, fresh night air. And the faint smell of roses and mystery.");
                }
            }

            // Room-specific background - Victorian house exterior at night
            drawRoom(worldWidth, height) {
                if (this.textures.exists('gardenBackground')) {
                    this.textures.remove('gardenBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Night sky gradient
                g.fillStyle(0x0a0a1a);
                g.fillRect(0, 0, worldWidth, height * 0.50);
                g.fillStyle(0x101025);
                g.fillRect(0, height * 0.25, worldWidth, height * 0.25);

                // Stars
                g.fillStyle(0xffffff);
                const starPositions = [
                    [50, 40], [120, 80], [200, 30], [280, 90], [350, 50],
                    [420, 70], [500, 25], [580, 85], [650, 45], [720, 95],
                    [800, 35], [880, 75], [950, 55], [1020, 40], [1100, 80],
                    [1180, 30], [1250, 65], [70, 120], [330, 110], [590, 130],
                    [850, 115], [1110, 105]
                ];
                starPositions.forEach(([x, y]) => {
                    const size = Math.random() > 0.7 ? 2 : 1;
                    g.fillCircle(x, y, size);
                });

                // Moon
                g.fillStyle(0xeeeedd);
                g.fillCircle(200, 100, 40);
                g.fillStyle(0xddddcc);
                g.fillCircle(190, 95, 8);
                g.fillCircle(210, 110, 6);
                g.fillCircle(195, 115, 4);

                // Dark woods (background, left side)
                g.fillStyle(0x0a1a0a);
                g.fillRect(0, height * 0.20, 350, height * 0.55);
                // Tree silhouettes
                g.fillStyle(0x051505);
                g.fillTriangle(50, height * 0.20, 0, height * 0.55, 100, height * 0.55);
                g.fillTriangle(120, height * 0.15, 60, height * 0.55, 180, height * 0.55);
                g.fillTriangle(200, height * 0.18, 140, height * 0.55, 260, height * 0.55);
                g.fillTriangle(280, height * 0.22, 220, height * 0.55, 340, height * 0.55);
                g.fillStyle(0x0a1a0a);
                g.fillTriangle(80, height * 0.25, 30, height * 0.55, 130, height * 0.55);
                g.fillTriangle(160, height * 0.20, 100, height * 0.55, 220, height * 0.55);
                g.fillTriangle(240, height * 0.23, 180, height * 0.55, 300, height * 0.55);

                // Ground/grass
                g.fillStyle(0x1a2a1a);
                g.fillRect(0, height * 0.70, worldWidth, height * 0.30);
                // Grass texture
                g.fillStyle(0x152515);
                for (let x = 0; x < worldWidth; x += 30) {
                    g.fillRect(x, height * 0.70, 15, height * 0.30);
                }

                // Garden path (dirt)
                g.fillStyle(0x3a2a1a);
                g.fillRect(400, height * 0.75, 500, height * 0.20);
                g.fillStyle(0x2a1a0a);
                for (let x = 420; x < 880; x += 60) {
                    g.fillCircle(x, height * 0.85, 8);
                }

                // Victorian House (right side)
                // Main structure
                g.fillStyle(0x3a3a4a);
                g.fillRect(850, height * 0.25, 400, height * 0.50);

                // Roof
                g.fillStyle(0x2a2a3a);
                g.fillTriangle(850, height * 0.25, 1050, height * 0.08, 1250, height * 0.25);
                // Roof shingles
                g.fillStyle(0x252535);
                for (let y = height * 0.12; y < height * 0.25; y += 15) {
                    const leftX = 850 + (1050 - 850) * (1 - (y - height * 0.08) / (height * 0.17));
                    const rightX = 1250 - (1250 - 1050) * (1 - (y - height * 0.08) / (height * 0.17));
                    g.fillRect(leftX, y, rightX - leftX, 8);
                }

                // Chimney
                g.fillStyle(0x4a3a3a);
                g.fillRect(1150, height * 0.05, 40, height * 0.15);
                g.fillStyle(0x5a4a4a);
                g.fillRect(1145, height * 0.03, 50, 10);

                // Windows (upper floor)
                g.fillStyle(0x1a1a2a);
                g.fillRect(900, height * 0.30, 60, 70);
                g.fillRect(1000, height * 0.30, 60, 70);
                g.fillRect(1140, height * 0.30, 60, 70);
                // Window frames
                g.lineStyle(3, 0x5a4a3a, 1);
                g.strokeRect(900, height * 0.30, 60, 70);
                g.strokeRect(1000, height * 0.30, 60, 70);
                g.strokeRect(1140, height * 0.30, 60, 70);
                // Window glow
                g.fillStyle(0x3a3a5a, 0.3);
                g.fillRect(902, height * 0.31, 56, 66);
                g.fillRect(1002, height * 0.31, 56, 66);
                // Window panes
                g.lineStyle(2, 0x4a3a2a, 1);
                g.moveTo(930, height * 0.30); g.lineTo(930, height * 0.30 + 70);
                g.moveTo(900, height * 0.30 + 35); g.lineTo(960, height * 0.30 + 35);
                g.moveTo(1030, height * 0.30); g.lineTo(1030, height * 0.30 + 70);
                g.moveTo(1000, height * 0.30 + 35); g.lineTo(1060, height * 0.30 + 35);
                g.moveTo(1170, height * 0.30); g.lineTo(1170, height * 0.30 + 70);
                g.moveTo(1140, height * 0.30 + 35); g.lineTo(1200, height * 0.30 + 35);
                g.strokePath();

                // Front door
                g.fillStyle(0x4a3020);
                g.fillRect(1000, height * 0.48, 80, height * 0.27);
                g.fillStyle(0x3a2010);
                g.fillRect(1010, height * 0.52, 25, height * 0.08);
                g.fillRect(1045, height * 0.52, 25, height * 0.08);
                g.fillRect(1010, height * 0.64, 25, height * 0.08);
                g.fillRect(1045, height * 0.64, 25, height * 0.08);
                g.fillStyle(0xc0a060);
                g.fillCircle(1065, height * 0.60, 5);
                g.lineStyle(3, 0x2a1808, 1);
                g.strokeRect(1000, height * 0.48, 80, height * 0.27);
                // Door frame
                g.fillStyle(0x5a4a3a);
                g.fillRect(990, height * 0.45, 100, 10);
                g.fillRect(990, height * 0.45, 8, height * 0.30);
                g.fillRect(1082, height * 0.45, 8, height * 0.30);

                // Porch
                g.fillStyle(0x4a3a2a);
                g.fillRect(950, height * 0.72, 180, height * 0.08);
                g.fillStyle(0x3a2a1a);
                g.fillRect(950, height * 0.72, 180, 5);

                // Rose bush (left of path)
                g.fillStyle(0x1a3a1a);
                g.fillCircle(150, height * 0.72, 50);
                g.fillCircle(200, height * 0.70, 45);
                g.fillCircle(120, height * 0.74, 35);
                // Roses
                g.fillStyle(0x8a2a3a);
                g.fillCircle(140, height * 0.68, 8);
                g.fillCircle(180, height * 0.66, 7);
                g.fillCircle(160, height * 0.72, 9);
                g.fillCircle(200, height * 0.70, 6);
                g.fillCircle(130, height * 0.75, 7);

                // Garden statue (cherub)
                g.fillStyle(0x7a7a8a);
                g.fillRect(440, height * 0.68, 20, height * 0.12);
                g.fillCircle(450, height * 0.65, 15);
                g.fillStyle(0x6a6a7a);
                g.fillCircle(445, height * 0.64, 4);
                g.fillCircle(455, height * 0.64, 4);

                // Lamp post near path
                g.fillStyle(0x2a2a2a);
                g.fillRect(380, height * 0.45, 8, height * 0.30);
                g.fillStyle(0x3a3a3a);
                g.fillRect(370, height * 0.42, 28, 20);
                g.fillStyle(0xffdd88);
                g.fillRect(375, height * 0.44, 18, 14);

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('gardenBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'gardenBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            // Room-specific lighting
            createLighting(worldWidth, height) {
                // Main moonlight - bright cool blue, large soft radius
                this.moonLight = this.lights.addLight(200, 100, 600, 0x8899cc, 0.9);
                // Secondary moon fill - very large for ambient moonlit feel
                this.moonFill = this.lights.addLight(640, height * 0.30, 800, 0x6677aa, 0.4);

                // Lamp post light - warm contrast to moonlight
                this.lampLight = this.lights.addLight(384, height * 0.50, 300, 0xffdd88, 1.1);
                this.lampLightBaseIntensity = 1.1;

                // Window glow from house - warm interior visible
                this.windowGlow1 = this.lights.addLight(930, height * 0.35, 150, 0x6677bb, 0.5);
                this.windowGlow2 = this.lights.addLight(1030, height * 0.35, 150, 0x6677bb, 0.5);

                // Door light - warm spill from interior
                this.doorLight = this.lights.addLight(1040, height * 0.58, 220, 0xffaa66, 0.7);

                // Ground fill for walkable area visibility
                this.groundFill = this.lights.addLight(640, height * 0.85, 600, 0x5566aa, 0.25);

                this.createLightBloom(height);
            }

            createLightBloom(height) {
                // Multi-layer moon glow for soft atmospheric effect
                const moonBloom1 = this.add.graphics();
                moonBloom1.fillStyle(0x8899cc, 0.08);
                moonBloom1.fillCircle(0, 0, 100);
                moonBloom1.setPosition(200, 100);
                moonBloom1.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom1.setDepth(1);

                const moonBloom2 = this.add.graphics();
                moonBloom2.fillStyle(0x6688bb, 0.06);
                moonBloom2.fillCircle(0, 0, 200);
                moonBloom2.setPosition(200, 100);
                moonBloom2.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom2.setDepth(1);

                const moonBloom3 = this.add.graphics();
                moonBloom3.fillStyle(0x5577aa, 0.04);
                moonBloom3.fillCircle(0, 0, 300);
                moonBloom3.setPosition(200, 100);
                moonBloom3.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom3.setDepth(1);

                // Multi-layer lamp glow for soft warm halo
                this.lampBloom1 = this.add.graphics();
                this.lampBloom1.fillStyle(0xffee99, 0.12);
                this.lampBloom1.fillCircle(0, 0, 50);
                this.lampBloom1.setPosition(384, height * 0.50);
                this.lampBloom1.setBlendMode(Phaser.BlendModes.ADD);
                this.lampBloom1.setDepth(1);

                this.lampBloom2 = this.add.graphics();
                this.lampBloom2.fillStyle(0xffdd88, 0.08);
                this.lampBloom2.fillCircle(0, 0, 100);
                this.lampBloom2.setPosition(384, height * 0.50);
                this.lampBloom2.setBlendMode(Phaser.BlendModes.ADD);
                this.lampBloom2.setDepth(1);

                this.lampBloom3 = this.add.graphics();
                this.lampBloom3.fillStyle(0xffcc66, 0.05);
                this.lampBloom3.fillCircle(0, 0, 160);
                this.lampBloom3.setPosition(384, height * 0.50);
                this.lampBloom3.setBlendMode(Phaser.BlendModes.ADD);
                this.lampBloom3.setDepth(1);

                // Door warm glow spill
                const doorBloom = this.add.graphics();
                doorBloom.fillStyle(0xffaa66, 0.08);
                doorBloom.fillCircle(0, 0, 100);
                doorBloom.setPosition(1040, height * 0.58);
                doorBloom.setBlendMode(Phaser.BlendModes.ADD);
                doorBloom.setDepth(1);
            }

            // Edge zones for scene transitions
            createEdgeZones(height) {
                // Left edge zone (exit to forest)
                this.leftEdgeZone = this.add.zone(40, height * 0.5, 80, height)
                    .setInteractive()
                    .setOrigin(0.5);

                this.leftEdgeZone.on('pointerover', () => {
                    if (!this.inventoryOpen && !this.verbCoinVisible) {
                        this.edgeHovered = 'left';
                        this.showArrowCursor('left');
                    }
                });

                this.leftEdgeZone.on('pointerout', () => {
                    this.edgeHovered = null;
                    this.hideArrowCursor();
                });

                this.leftEdgeZone.on('pointerdown', (pointer) => {
                    if (this.inventoryOpen) return;

                    // Prevent main input handler from overriding our walk
                    this.clickedUI = true;

                    const currentTime = Date.now();
                    const isDoubleClick = (currentTime - (this.edgeClickTime || 0)) < 300;
                    this.edgeClickTime = currentTime;

                    if (isDoubleClick) {
                        // Immediate transition
                        this.hideArrowCursor();
                        this.transitionToScene('ForestScene', 'from_garden');
                    } else {
                        // Walk to edge then transition
                        this.hideArrowCursor();
                        this.walkToEdgeAndTransition(80, height * 0.80, 'ForestScene', 'from_garden');
                    }
                });
            }

            walkToEdgeAndTransition(targetX, targetY, scene, spawnPoint) {
                this.walkTo(targetX, targetY, () => {
                    this.transitionToScene(scene, spawnPoint);
                }, false);
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                if (action === 'Use') {
                    if (hotspot.name === 'Front Door') {
                        this.transitionToScene('GameScene', 'left');
                    } else {
                        this.showDialog(hotspot.useResponse);
                    }
                } else if (action === 'Look At') {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Talk To') {
                    this.showDialog(hotspot.talkResponse);
                }
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Front Door') {
                    this.showDialog("The door's not locked. I can just use it.");
                } else if (hotspot.name === 'Rose Bush') {
                    this.showDialog(`Using ${item.name} on roses? That's not how gardening works.`);
                } else {
                    this.showDialog(`That doesn't work.`);
                }
            }

            update() {
                super.update();

                // Organic lamp flicker - gas lamp style
                if (this.lampLight) {
                    const time = this.time.now * 0.001;

                    // Multiple frequencies for organic flicker
                    const flicker1 = Math.sin(time * 5) * 0.08;
                    const flicker2 = Math.sin(time * 11 + 0.7) * 0.05;
                    const flicker3 = Math.sin(time * 19 + 1.3) * 0.03;
                    const totalFlicker = flicker1 + flicker2 + flicker3;

                    this.lampLight.intensity = this.lampLightBaseIntensity + totalFlicker;

                    // Animate lamp bloom opacity
                    if (this.lampBloom1) {
                        this.lampBloom1.setAlpha(0.9 + totalFlicker * 0.3);
                        this.lampBloom2.setAlpha(0.8 + totalFlicker * 0.25);
                    }
                }
            }
        }

        // ============================================================================
        // FOREST SCENE - Dark Spooky Forest with Graveyard (extends BaseScene)
        // ============================================================================
        class ForestScene extends BaseScene {
            constructor() {
                super({ key: 'ForestScene' });
                this.worldWidth = 3840; // 3x screen width
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.72, maxY: 0.94 };
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                return [
                    {
                        x: 600, y: height * 0.65, w: 120, h: height * 0.25,
                        interactX: 650, interactY: height * 0.82,
                        name: 'Twisted Oak',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "An ancient oak, gnarled and twisted. Its branches look like reaching fingers.",
                        useResponse: "The bark feels... warm? That's not normal for a tree.",
                        talkResponse: "Psst. Hey tree. Blink twice if you're alive. ...Okay, good talk."
                    },
                    {
                        x: 1200, y: height * 0.72, w: 80, h: height * 0.15,
                        interactX: 1250, interactY: height * 0.82,
                        name: 'Old Tombstone',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Read', talkVerb: 'Talk to' },
                        lookResponse: "RIP Bartholomew Grimshaw, 1823-1867. 'He finally got some peace and quiet.'",
                        useResponse: "Not touching that. Learned my lesson from that zombie movie.",
                        talkResponse: "Hello? Mr. Grimshaw? ...No answer. Phew. I mean, how sad."
                    },
                    {
                        x: 1500, y: height * 0.70, w: 70, h: height * 0.18,
                        interactX: 1550, interactY: height * 0.82,
                        name: 'Crooked Headstone',
                        verbLabels: { actionVerb: 'Push', lookVerb: 'Read', talkVerb: 'Talk to' },
                        lookResponse: "A weathered stone. The inscription reads: 'I told you I was sick.'",
                        useResponse: "It wobbles slightly. I'd rather not disturb the occupant.",
                        talkResponse: "Any wisdom from beyond the grave? ...Just an awkward silence? Fair enough."
                    },
                    {
                        x: 2200, y: height * 0.55, w: 100, h: height * 0.30,
                        interactX: 2250, interactY: height * 0.80,
                        name: 'Wisp Light',
                        verbLabels: { actionVerb: 'Catch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A floating ball of ethereal light. Either supernatural or very lost fireflies.",
                        useResponse: "It drifts away as I reach for it. Playing hard to get, I see.",
                        talkResponse: "Take me to your leader! ...It just bobs there judgmentally."
                    },
                    {
                        x: 2800, y: height * 0.60, w: 150, h: height * 0.28,
                        interactX: 2750, interactY: height * 0.82,
                        name: 'Dead Tree',
                        verbLabels: { actionVerb: 'Shake', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A skeletal tree, completely dead. Ravens have made it their home.",
                        useResponse: "I shake the trunk. A raven caws angrily. Point taken.",
                        talkResponse: "Caw caw? ...The ravens don't seem impressed by my bird impression."
                    },
                    {
                        x: 1800, y: height * 0.74, w: 90, h: height * 0.12,
                        interactX: 1800, interactY: height * 0.82,
                        name: 'Freshly Dug Grave',
                        verbLabels: { actionVerb: 'Dig', lookVerb: 'Examine', talkVerb: 'Call out to' },
                        lookResponse: "A fresh grave. The dirt is still loose. I'm sure there's a perfectly normal explanation.",
                        useResponse: "Nope. Not digging. Some mysteries are better left buried. Literally.",
                        talkResponse: "Anyone down there? ...I'm going to assume that silence is good news."
                    }
                ];
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup for wide scrolling scene
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - spooky forest ambient (bright but eerie)
                this.lights.enable();
                const isMobile = this.sys.game.device.input.touch;
                this.lights.setAmbientColor(isMobile ? 0x8a8aaa : 0x6a6a8a); // Brighter on mobile

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Create fog effects
                this.createFogEffects(height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create edge transition zones
                this.createEdgeZones(height);

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = this.worldWidth / 2;
                if (spawnPoint === 'from_garden') spawnX = this.worldWidth - 150;
                else if (spawnPoint === 'left') spawnX = 150;

                this.createPlayer(spawnX, height * 0.82);

                // Center camera on player
                this.cameras.main.scrollX = Phaser.Math.Clamp(
                    spawnX - this.screenWidth / 2, 0, this.worldWidth - this.screenWidth
                );

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('forest')) {
                    state.visitedRooms.push('forest');
                    this.setGameState(state);
                    this.showDialog("Well, this isn't creepy at all. Said no one, ever.");
                }
            }

            // Room-specific background - Dark spooky forest with graveyard
            drawRoom(worldWidth, height) {
                if (this.textures.exists('forestBackground')) {
                    this.textures.remove('forestBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Very dark sky
                g.fillStyle(0x050510);
                g.fillRect(0, 0, worldWidth, height * 0.60);
                g.fillStyle(0x0a0a15);
                g.fillRect(0, height * 0.30, worldWidth, height * 0.30);

                // Sparse stars (barely visible through canopy)
                g.fillStyle(0x333355);
                const starPositions = [
                    [200, 50], [800, 80], [1500, 40], [2200, 70], [2900, 55],
                    [500, 100], [1200, 90], [1900, 60], [2600, 85], [3400, 45],
                    [100, 120], [700, 110], [1400, 130], [2100, 95], [3000, 115]
                ];
                starPositions.forEach(([x, y]) => {
                    g.fillCircle(x, y, 1);
                });

                // Eerie moon (partially hidden)
                g.fillStyle(0x334455);
                g.fillCircle(2400, 80, 50);
                g.fillStyle(0x050510);
                g.fillCircle(2430, 70, 45); // Moon shadow

                // Forest ground - dark earth
                g.fillStyle(0x0a0f0a);
                g.fillRect(0, height * 0.72, worldWidth, height * 0.28);
                // Ground texture
                g.fillStyle(0x080c08);
                for (let x = 0; x < worldWidth; x += 40) {
                    g.fillRect(x, height * 0.72, 20, height * 0.28);
                }

                // Dirt path through forest
                g.fillStyle(0x1a1510);
                g.fillRect(0, height * 0.80, worldWidth, height * 0.12);
                g.fillStyle(0x151008);
                for (let x = 50; x < worldWidth; x += 80) {
                    g.fillCircle(x, height * 0.86, 6);
                }

                // ===== FAR BACKGROUND TREES (silhouettes) =====
                g.fillStyle(0x080808);
                for (let x = 0; x < worldWidth; x += 200) {
                    const treeHeight = height * (0.35 + Math.random() * 0.15);
                    const baseY = height * 0.60;
                    // Trunk
                    g.fillRect(x + 90, baseY - treeHeight * 0.5, 20, treeHeight * 0.5);
                    // Canopy layers
                    g.fillTriangle(x + 100, baseY - treeHeight, x + 50, baseY - treeHeight * 0.4, x + 150, baseY - treeHeight * 0.4);
                    g.fillTriangle(x + 100, baseY - treeHeight * 0.7, x + 40, baseY - treeHeight * 0.2, x + 160, baseY - treeHeight * 0.2);
                }

                // ===== GRAVEYARD SECTION (center-left area: 900-2100) =====
                // Iron fence
                g.fillStyle(0x1a1a1a);
                g.fillRect(900, height * 0.68, 1200, 8);
                g.fillStyle(0x252525);
                for (let x = 920; x < 2100; x += 60) {
                    g.fillRect(x, height * 0.55, 6, height * 0.15);
                    // Fence spike tops
                    g.fillTriangle(x + 3, height * 0.52, x - 2, height * 0.55, x + 8, height * 0.55);
                }

                // Tombstones
                this.drawTombstone(g, 1000, height, 0.70, 'cross');
                this.drawTombstone(g, 1200, height, 0.72, 'rounded');
                this.drawTombstone(g, 1400, height, 0.69, 'pointed');
                this.drawTombstone(g, 1500, height, 0.71, 'rounded');
                this.drawTombstone(g, 1700, height, 0.70, 'cross');
                this.drawTombstone(g, 1900, height, 0.72, 'pointed');

                // Freshly dug grave (dirt mound)
                g.fillStyle(0x1a120a);
                g.fillRect(1750, height * 0.76, 100, height * 0.06);
                g.fillStyle(0x251a10);
                g.fillRect(1760, height * 0.74, 80, height * 0.04);
                // Shovel
                g.fillStyle(0x3a3a3a);
                g.fillRect(1860, height * 0.60, 6, height * 0.20);
                g.fillStyle(0x555555);
                g.fillRect(1855, height * 0.78, 16, 20);

                // ===== TWISTED TREES =====
                // Twisted Oak (left section)
                this.drawTwistedTree(g, 550, height, 0.72, 0x1a1008, 0x0a0804);

                // Dead tree with ravens (right section)
                this.drawDeadTree(g, 2800, height, 0.72);

                // More atmospheric trees
                this.drawTwistedTree(g, 150, height, 0.68, 0x151008, 0x0a0804);
                this.drawTwistedTree(g, 3200, height, 0.70, 0x181008, 0x0a0804);
                this.drawTwistedTree(g, 3500, height, 0.69, 0x141008, 0x0a0804);

                // ===== FOREGROUND ELEMENTS =====
                // Mushrooms (bioluminescent hints)
                g.fillStyle(0x1a2a1a);
                g.fillCircle(300, height * 0.88, 8);
                g.fillCircle(310, height * 0.89, 6);
                g.fillCircle(2500, height * 0.87, 7);
                g.fillCircle(3100, height * 0.89, 9);

                // Fallen log
                g.fillStyle(0x1a1008);
                g.fillRect(400, height * 0.85, 150, 25);
                g.fillStyle(0x0f0a05);
                g.fillCircle(400, height * 0.86, 12);
                g.fillCircle(550, height * 0.86, 12);

                // Rocks
                g.fillStyle(0x2a2a2a);
                g.fillCircle(100, height * 0.88, 15);
                g.fillCircle(3700, height * 0.87, 20);
                g.fillCircle(3720, height * 0.89, 12);

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('forestBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'forestBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            drawTombstone(g, x, height, yPos, style) {
                g.fillStyle(0x3a3a3a);
                if (style === 'cross') {
                    g.fillRect(x - 5, height * yPos - 60, 10, 70);
                    g.fillRect(x - 20, height * yPos - 45, 40, 10);
                } else if (style === 'rounded') {
                    g.fillRect(x - 20, height * yPos - 40, 40, 50);
                    g.fillCircle(x, height * yPos - 40, 20);
                } else if (style === 'pointed') {
                    g.fillRect(x - 18, height * yPos - 35, 36, 45);
                    g.fillTriangle(x, height * yPos - 55, x - 18, height * yPos - 35, x + 18, height * yPos - 35);
                }
                // Weathering
                g.fillStyle(0x2a2a2a);
                g.fillRect(x - 15, height * yPos - 20, 5, 15);
                g.fillRect(x + 5, height * yPos - 30, 8, 10);
            }

            drawTwistedTree(g, x, height, groundY, trunkColor, darkColor) {
                // Gnarled trunk
                g.fillStyle(trunkColor);
                g.fillRect(x - 15, height * groundY - 180, 30, 190);
                g.fillRect(x - 25, height * groundY - 150, 50, 30);

                // Twisted branches
                g.fillStyle(darkColor);
                // Main branches
                g.fillTriangle(x, height * groundY - 180, x - 80, height * groundY - 250, x - 60, height * groundY - 200);
                g.fillTriangle(x, height * groundY - 170, x + 90, height * groundY - 230, x + 70, height * groundY - 190);
                g.fillTriangle(x, height * groundY - 160, x - 50, height * groundY - 280, x - 30, height * groundY - 220);
                g.fillTriangle(x, height * groundY - 150, x + 60, height * groundY - 270, x + 40, height * groundY - 200);

                // Reaching finger-like twigs
                g.fillStyle(0x0a0804);
                for (let i = 0; i < 5; i++) {
                    const branchX = x - 70 + i * 35;
                    const branchY = height * groundY - 240 - Math.random() * 40;
                    g.fillRect(branchX, branchY, 3, 25 + Math.random() * 15);
                }

                // Roots
                g.fillStyle(trunkColor);
                g.fillTriangle(x - 25, height * groundY, x - 50, height * groundY + 10, x - 15, height * groundY);
                g.fillTriangle(x + 25, height * groundY, x + 50, height * groundY + 10, x + 15, height * groundY);
            }

            drawDeadTree(g, x, height, groundY) {
                // Skeletal trunk
                g.fillStyle(0x1a1510);
                g.fillRect(x - 20, height * groundY - 200, 40, 210);

                // Bare branches
                g.fillStyle(0x151008);
                g.fillRect(x - 100, height * groundY - 180, 80, 8);
                g.fillRect(x + 20, height * groundY - 160, 90, 8);
                g.fillRect(x - 70, height * groundY - 140, 60, 6);
                g.fillRect(x + 30, height * groundY - 190, 70, 6);

                // Branch ends
                g.fillRect(x - 100, height * groundY - 200, 6, 25);
                g.fillRect(x + 100, height * groundY - 175, 6, 20);
                g.fillRect(x - 70, height * groundY - 160, 5, 25);
                g.fillRect(x + 90, height * groundY - 205, 5, 20);

                // Ravens (silhouettes)
                g.fillStyle(0x0a0a0a);
                g.fillCircle(x - 90, height * groundY - 185, 8);
                g.fillTriangle(x - 100, height * groundY - 185, x - 90, height * groundY - 190, x - 90, height * groundY - 180);
                g.fillCircle(x + 85, height * groundY - 165, 7);
                g.fillTriangle(x + 75, height * groundY - 165, x + 85, height * groundY - 170, x + 85, height * groundY - 160);
            }

            // Room-specific lighting
            createLighting(worldWidth, height) {
                // Moonlight filtering through trees - multiple sources for varied lighting
                this.moonLight = this.lights.addLight(2400, 80, 700, 0x5566aa, 0.5);
                this.moonFill1 = this.lights.addLight(800, height * 0.30, 500, 0x4455aa, 0.3);
                this.moonFill2 = this.lights.addLight(2000, height * 0.25, 600, 0x4455aa, 0.35);

                // Eerie wisp lights (ghostly green/cyan) - larger radius, brighter
                this.wispLight1 = this.lights.addLight(600, height * 0.50, 250, 0x55ffaa, 0.8);
                this.wispLight2 = this.lights.addLight(2200, height * 0.55, 280, 0x77ffcc, 0.9);
                this.wispLight3 = this.lights.addLight(3000, height * 0.48, 220, 0x99ffdd, 0.7);

                // Base intensities for pulsing animation
                this.wispBaseIntensity1 = 0.8;
                this.wispBaseIntensity2 = 0.9;
                this.wispBaseIntensity3 = 0.7;

                // Graveyard ambient (cold blue) - brighter for visibility
                this.graveyardLight = this.lights.addLight(1500, height * 0.70, 600, 0x4455bb, 0.45);

                // Mushroom glow - bioluminescent feel
                this.mushroomGlow1 = this.lights.addLight(305, height * 0.86, 100, 0x55cc77, 0.5);
                this.mushroomGlow2 = this.lights.addLight(2500, height * 0.85, 80, 0x55cc77, 0.4);

                // General fill for visibility in dark areas
                this.fillLight1 = this.lights.addLight(400, height * 0.70, 400, 0x445566, 0.25);
                this.fillLight2 = this.lights.addLight(1200, height * 0.70, 400, 0x445566, 0.25);
                this.fillLight3 = this.lights.addLight(2600, height * 0.70, 400, 0x445566, 0.25);
                this.fillLight4 = this.lights.addLight(3400, height * 0.70, 400, 0x445566, 0.25);

                this.createLightBloom(height);
            }

            createLightBloom(height) {
                // Multi-layer wisp blooms for ethereal glow effect
                // Wisp 1 - inner bright, outer soft
                this.wispBloom1Inner = this.add.graphics();
                this.wispBloom1Inner.fillStyle(0x55ffaa, 0.15);
                this.wispBloom1Inner.fillCircle(0, 0, 60);
                this.wispBloom1Inner.setPosition(600, height * 0.50);
                this.wispBloom1Inner.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom1Inner.setDepth(1);

                this.wispBloom1 = this.add.graphics();
                this.wispBloom1.fillStyle(0x44ff88, 0.08);
                this.wispBloom1.fillCircle(0, 0, 120);
                this.wispBloom1.setPosition(600, height * 0.50);
                this.wispBloom1.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom1.setDepth(1);

                this.wispBloom1Outer = this.add.graphics();
                this.wispBloom1Outer.fillStyle(0x33dd77, 0.04);
                this.wispBloom1Outer.fillCircle(0, 0, 180);
                this.wispBloom1Outer.setPosition(600, height * 0.50);
                this.wispBloom1Outer.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom1Outer.setDepth(1);

                // Wisp 2
                this.wispBloom2Inner = this.add.graphics();
                this.wispBloom2Inner.fillStyle(0x77ffcc, 0.18);
                this.wispBloom2Inner.fillCircle(0, 0, 70);
                this.wispBloom2Inner.setPosition(2200, height * 0.55);
                this.wispBloom2Inner.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom2Inner.setDepth(1);

                this.wispBloom2 = this.add.graphics();
                this.wispBloom2.fillStyle(0x66ffaa, 0.10);
                this.wispBloom2.fillCircle(0, 0, 140);
                this.wispBloom2.setPosition(2200, height * 0.55);
                this.wispBloom2.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom2.setDepth(1);

                this.wispBloom2Outer = this.add.graphics();
                this.wispBloom2Outer.fillStyle(0x55dd99, 0.05);
                this.wispBloom2Outer.fillCircle(0, 0, 200);
                this.wispBloom2Outer.setPosition(2200, height * 0.55);
                this.wispBloom2Outer.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom2Outer.setDepth(1);

                // Wisp 3
                this.wispBloom3Inner = this.add.graphics();
                this.wispBloom3Inner.fillStyle(0x99ffdd, 0.12);
                this.wispBloom3Inner.fillCircle(0, 0, 50);
                this.wispBloom3Inner.setPosition(3000, height * 0.48);
                this.wispBloom3Inner.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom3Inner.setDepth(1);

                this.wispBloom3 = this.add.graphics();
                this.wispBloom3.fillStyle(0x88ffcc, 0.08);
                this.wispBloom3.fillCircle(0, 0, 100);
                this.wispBloom3.setPosition(3000, height * 0.48);
                this.wispBloom3.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom3.setDepth(1);

                this.wispBloom3Outer = this.add.graphics();
                this.wispBloom3Outer.fillStyle(0x77ddbb, 0.04);
                this.wispBloom3Outer.fillCircle(0, 0, 150);
                this.wispBloom3Outer.setPosition(3000, height * 0.48);
                this.wispBloom3Outer.setBlendMode(Phaser.BlendModes.ADD);
                this.wispBloom3Outer.setDepth(1);

                // Moon glow - multi-layer for soft atmospheric effect
                const moonBloom1 = this.add.graphics();
                moonBloom1.fillStyle(0x5566aa, 0.08);
                moonBloom1.fillCircle(0, 0, 120);
                moonBloom1.setPosition(2400, 80);
                moonBloom1.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom1.setDepth(1);

                const moonBloom2 = this.add.graphics();
                moonBloom2.fillStyle(0x445588, 0.05);
                moonBloom2.fillCircle(0, 0, 200);
                moonBloom2.setPosition(2400, 80);
                moonBloom2.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom2.setDepth(1);

                // Mushroom glow halos
                const mushroomBloom1 = this.add.graphics();
                mushroomBloom1.fillStyle(0x55cc77, 0.1);
                mushroomBloom1.fillCircle(0, 0, 50);
                mushroomBloom1.setPosition(305, height * 0.86);
                mushroomBloom1.setBlendMode(Phaser.BlendModes.ADD);
                mushroomBloom1.setDepth(1);

                const mushroomBloom2 = this.add.graphics();
                mushroomBloom2.fillStyle(0x55cc77, 0.08);
                mushroomBloom2.fillCircle(0, 0, 40);
                mushroomBloom2.setPosition(2500, height * 0.85);
                mushroomBloom2.setBlendMode(Phaser.BlendModes.ADD);
                mushroomBloom2.setDepth(1);
            }

            createFogEffects(height) {
                // Ground fog layers
                this.fogLayers = [];

                for (let i = 0; i < 4; i++) {
                    const fog = this.add.graphics();
                    fog.fillStyle(0x1a1a2a, 0.15 - i * 0.03);

                    // Draw wavy fog
                    for (let x = 0; x < this.worldWidth; x += 200) {
                        const yOffset = Math.sin(x * 0.01 + i) * 10;
                        fog.fillEllipse(x, height * (0.78 + i * 0.03) + yOffset, 250, 30);
                    }

                    fog.setDepth(2 + i);
                    fog.setBlendMode(Phaser.BlendModes.ADD);
                    this.fogLayers.push(fog);
                }
            }

            createEdgeZones(height) {
                // Right edge zone (exit to garden)
                this.rightEdgeZone = this.add.zone(this.worldWidth - 40, height * 0.5, 80, height)
                    .setInteractive()
                    .setOrigin(0.5);

                this.rightEdgeZone.on('pointerover', () => {
                    if (!this.inventoryOpen && !this.verbCoinVisible) {
                        this.edgeHovered = 'right';
                        this.showArrowCursor('right');
                    }
                });

                this.rightEdgeZone.on('pointerout', () => {
                    this.edgeHovered = null;
                    this.hideArrowCursor();
                });

                this.rightEdgeZone.on('pointerdown', (pointer) => {
                    if (this.inventoryOpen) return;

                    // Prevent main input handler from overriding our walk
                    this.clickedUI = true;

                    const currentTime = Date.now();
                    const isDoubleClick = (currentTime - (this.edgeClickTime || 0)) < 300;
                    this.edgeClickTime = currentTime;

                    if (isDoubleClick) {
                        // Immediate transition
                        this.hideArrowCursor();
                        this.transitionToScene('GardenScene', 'from_forest');
                    } else {
                        // Walk to edge then transition
                        this.hideArrowCursor();
                        this.walkToEdgeAndTransition(this.worldWidth - 80, height * 0.82, 'GardenScene', 'from_forest');
                    }
                });
            }

            walkToEdgeAndTransition(targetX, targetY, scene, spawnPoint) {
                this.walkTo(targetX, targetY, () => {
                    this.transitionToScene(scene, spawnPoint);
                }, false);
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                if (action === 'Look At') {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Use') {
                    this.showDialog(hotspot.useResponse);
                } else if (action === 'Talk To') {
                    this.showDialog(hotspot.talkResponse);
                }
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Old Tombstone' || hotspot.name === 'Crooked Headstone') {
                    this.showDialog("Leaving offerings for the dead? How thoughtful. And creepy.");
                } else if (hotspot.name === 'Wisp Light') {
                    this.showDialog("The wisp seems unimpressed by my earthly possessions.");
                } else {
                    this.showDialog(`That doesn't seem useful here.`);
                }
            }

            update() {
                super.update();

                const { height } = this.scale;

                // Animate wisp lights with eerie slow pulsing
                if (this.wispLight1) {
                    const time = this.time.now * 0.001;

                    // Slow ethereal floating motion
                    const y1 = height * 0.50 + Math.sin(time * 0.8) * 25 + Math.sin(time * 1.7) * 10;
                    const y2 = height * 0.55 + Math.sin(time * 0.6 + 1) * 30 + Math.sin(time * 1.3) * 12;
                    const y3 = height * 0.48 + Math.sin(time * 0.9 + 2) * 20 + Math.sin(time * 2.1) * 8;

                    // Slight horizontal drift
                    const x1Drift = Math.sin(time * 0.5) * 15;
                    const x2Drift = Math.sin(time * 0.4 + 1.5) * 20;
                    const x3Drift = Math.sin(time * 0.6 + 0.8) * 12;

                    this.wispLight1.y = y1;
                    this.wispLight2.y = y2;
                    this.wispLight3.y = y3;
                    this.wispLight1.x = 600 + x1Drift;
                    this.wispLight2.x = 2200 + x2Drift;
                    this.wispLight3.x = 3000 + x3Drift;

                    // Eerie slow pulsing - different frequencies for organic feel
                    const pulse1 = Math.sin(time * 1.2) * 0.25 + Math.sin(time * 2.7) * 0.1;
                    const pulse2 = Math.sin(time * 0.9 + 0.5) * 0.3 + Math.sin(time * 2.3 + 1) * 0.12;
                    const pulse3 = Math.sin(time * 1.1 + 1.2) * 0.2 + Math.sin(time * 3.1 + 0.7) * 0.08;

                    this.wispLight1.intensity = this.wispBaseIntensity1 + pulse1;
                    this.wispLight2.intensity = this.wispBaseIntensity2 + pulse2;
                    this.wispLight3.intensity = this.wispBaseIntensity3 + pulse3;

                    // Update all bloom positions to follow lights
                    if (this.wispBloom1) {
                        this.wispBloom1.setPosition(this.wispLight1.x, y1);
                        this.wispBloom1Inner.setPosition(this.wispLight1.x, y1);
                        this.wispBloom1Outer.setPosition(this.wispLight1.x, y1);

                        this.wispBloom2.setPosition(this.wispLight2.x, y2);
                        this.wispBloom2Inner.setPosition(this.wispLight2.x, y2);
                        this.wispBloom2Outer.setPosition(this.wispLight2.x, y2);

                        this.wispBloom3.setPosition(this.wispLight3.x, y3);
                        this.wispBloom3Inner.setPosition(this.wispLight3.x, y3);
                        this.wispBloom3Outer.setPosition(this.wispLight3.x, y3);

                        // Animate bloom opacity for ethereal glow effect
                        this.wispBloom1Inner.setAlpha(0.8 + pulse1 * 0.4);
                        this.wispBloom1.setAlpha(0.6 + pulse1 * 0.3);
                        this.wispBloom1Outer.setAlpha(0.4 + pulse1 * 0.2);

                        this.wispBloom2Inner.setAlpha(0.85 + pulse2 * 0.35);
                        this.wispBloom2.setAlpha(0.65 + pulse2 * 0.25);
                        this.wispBloom2Outer.setAlpha(0.45 + pulse2 * 0.2);

                        this.wispBloom3Inner.setAlpha(0.75 + pulse3 * 0.4);
                        this.wispBloom3.setAlpha(0.55 + pulse3 * 0.3);
                        this.wispBloom3Outer.setAlpha(0.35 + pulse3 * 0.2);
                    }
                }

                // Animate fog layers (slow drift)
                if (this.fogLayers) {
                    const time = this.time.now * 0.0001;
                    this.fogLayers.forEach((fog, i) => {
                        fog.x = Math.sin(time + i * 0.7) * 40;
                    });
                }

                // Subtle mushroom glow pulse
                if (this.mushroomGlow1) {
                    const time = this.time.now * 0.001;
                    const mushroomPulse = Math.sin(time * 1.5) * 0.1;
                    this.mushroomGlow1.intensity = 0.5 + mushroomPulse;
                    this.mushroomGlow2.intensity = 0.4 + mushroomPulse * 0.8;
                }
            }
        }

        // ============================================================================
        // LABORATORY SCENE - Mad Scientist's Workshop
        // ============================================================================
        class LaboratoryScene extends BaseScene {
            constructor() {
                super({ key: 'LaboratoryScene' });
                this.worldWidth = 2560; // 2x screen width
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.68, maxY: 0.90 };
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                return [
                    {
                        x: 150, y: height * 0.45, w: 100, h: height * 0.35,
                        interactX: 220, interactY: height * 0.78,
                        name: 'Door to House',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "The way back to sanity. Or at least, back to rooms without interdimensional portals.",
                        useResponse: "TRANSITION_TO_HOUSE",
                        talkResponse: "You're my favorite door. Don't tell the others."
                    },
                    {
                        x: 1280, y: height * 0.35, w: 280, h: height * 0.40,
                        interactX: 1280, interactY: height * 0.78,
                        name: 'Portal Device',
                        verbLabels: { actionVerb: 'Examine', lookVerb: 'Study', talkVerb: 'Talk to' },
                        lookResponse: "A swirling vortex of otherworldly energy. Either a gateway to another dimension or the world's most dangerous lava lamp.",
                        useResponse: "Sure, let me just stick my hand into the crackling void. ...On second thought, I'd like to keep all my fingers.",
                        talkResponse: "Hello? Anyone home? ...Nothing. Either nobody's there, or they're screening my calls."
                    },
                    {
                        x: 2100, y: height * 0.40, w: 200, h: height * 0.35,
                        interactX: 2000, interactY: height * 0.78,
                        name: 'Control Terminal',
                        verbLabels: { actionVerb: 'Use', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Blinking lights, ominous switches, and three buttons labeled 'DO NOT PRESS'. So naturally...",
                        useResponse: "Alright, let's flip something and see what happens. ...Huh. Nothing exploded. Disappointing, honestly.",
                        talkResponse: "Beep boop? ...Right. The strong, silent type."
                    },
                    {
                        x: 650, y: height * 0.35, w: 150, h: height * 0.30,
                        interactX: 650, interactY: height * 0.78,
                        name: 'Tesla Coil',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Crackling electricity, copper coils, chrome sphere on top. Either mad science or a very aggressive lamp.",
                        useResponse: "Touch the giant lightning machine? Bold strategy. Let's see how that... BZZZT! ...Noted.",
                        talkResponse: "BZZZT! Was that 'hello' or 'go away'? Hard to tell with Tesla coils."
                    },
                    {
                        x: 1800, y: height * 0.55, w: 120, h: height * 0.25,
                        interactX: 1750, interactY: height * 0.78,
                        name: 'Equipment Shelf',
                        verbLabels: { actionVerb: 'Search', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Beakers, tubes, bubbling liquids, and... is that a brain in a jar? Please be decorative. Please be decorative.",
                        useResponse: "Let's see if there's anything useful in... whoops. That beaker wasn't important, right?",
                        talkResponse: "If anything here is sentient, now's the time to speak up. ...Okay good. Just checking."
                    },
                    {
                        x: 400, y: height * 0.50, w: 100, h: height * 0.25,
                        interactX: 450, interactY: height * 0.78,
                        name: 'Chalkboard',
                        verbLabels: { actionVerb: 'Read', lookVerb: 'Study', talkVerb: 'Talk to' },
                        lookResponse: "Equations, diagrams, arcane symbols. Either groundbreaking physics or someone really committed to their doodles.",
                        useResponse: "Might as well add something. There. A little smiley face. My contribution to science.",
                        talkResponse: "E equals MC... squared? Cubed? ...Math remains unimpressed by my guesses."
                    },
                    {
                        x: 2050, y: height * 0.55, w: 80, h: height * 0.30,
                        interactX: 1950, interactY: height * 0.78,
                        name: 'Dr. Manzana',
                        isNPC: true,
                        verbLabels: { actionVerb: 'Poke', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A composed man in a pristine lab coat. Slick dark hair, goggles pushed up on his forehead, a meticulous mustache. He's focused intently on the terminal.",
                        useResponse: "Poking a scientist mid-experiment seems unwise. Maybe just talk to him?",
                        talkResponse: "START_CONVERSATION"
                    }
                ];
            }

            // Scientist dialogue tree - Dr. Hector Manzana
            getScientistDialogue() {
                return {
                    start: {
                        options: [
                            {
                                text: "Hi, I'm here about the job posting.",
                                heroLine: "Hi there! I'm Nate - Nathaniel Barnswallow. I'm here about the job posting in Fringe Science Quarterly?",
                                npcResponse: "The job posting. Hm. I don't entirely remember placing that, but... well, the universe works in mysterious ways. And I could use an extra pair of hands tonight. You any good with instruments?",
                                nextNode: 'hiring',
                                setFlag: 'introduced_self',
                                condition: (scene) => !scene.getFlag('introduced_self')
                            },
                            {
                                text: "What's with the swirling vortex?",
                                heroLine: "So that swirling vortex of unknown energy in the middle of the room... should I be concerned, or...?",
                                npcResponse: "The Resonance Gateway? Nah, she's gentle. Mostly. Tonight's the night we finally get a stable connection. Years of work, all coming together. It's actually quite exciting. In a 'could alter the fabric of reality' sort of way.",
                                nextNode: 'portal_questions',
                                setFlag: 'asked_portal',
                                condition: (scene) => scene.getFlag('hired_for_night')
                            },
                            {
                                text: "What do you need me to do?",
                                heroLine: "So what do you need me to do? I'm eager to help. Possibly too eager. It's a character flaw.",
                                npcResponse: "Ha! I like you already. Okay, simple job - keep an eye on that terminal over there. If the numbers go into the red, holler. If they go into the purple, run. I'll handle the rest.",
                                nextNode: 'tasks',
                                setFlag: 'asked_tasks',
                                condition: (scene) => scene.getFlag('hired_for_night') && !scene.getFlag('asked_tasks')
                            },
                            {
                                text: "I noticed some unusual things around here...",
                                heroLine: "I couldn't help but notice some... unusual things around the house. Anything I should know about?",
                                npcResponse: "You'll have to be more specific. 'Unusual' covers a lot of ground around here. I've learned to be very precise with my vocabulary.",
                                nextNode: 'houseguests',
                                condition: (scene) => scene.getFlag('hired_for_night')
                            },
                            {
                                text: "Most scientists would call this insane.",
                                heroLine: "Most scientists would call this kind of research... how do I put this diplomatically... completely insane?",
                                npcResponse: "Oh, they do. Frequently. But here's the thing - I get results. Real, measurable, occasionally terrifying results. Hard to argue with data, even when the data suggests reality is more flexible than people like to believe.",
                                nextNode: 'philosophy',
                                setFlag: 'asked_philosophy',
                                condition: (scene) => scene.getFlag('hired_for_night') && !scene.getFlag('asked_philosophy')
                            },
                            {
                                text: "I'll let you get back to work.",
                                heroLine: "I'll let you get back to it. Don't let me interrupt the... reality bending.",
                                npcResponse: "Appreciated. Stick around though - when the readings stabilize, things might get interesting. And by interesting I mean potentially catastrophic. In a good way.",
                                exit: true,
                                condition: (scene) => scene.getFlag('hired_for_night')
                            }
                        ]
                    },
                    hiring: {
                        options: [
                            {
                                text: "I love instruments! Well, I've read about them.",
                                heroLine: "Instruments? I love instruments. Well, I've read about them. Extensively. I'm basically an expert who's never touched one.",
                                npcResponse: "Perfect. You'll fit right in. I'm Hector, by the way. Dr. Manzana if we're being formal, but we're not. Welcome to the night shift. Try not to die.",
                                setFlag: 'hired_for_night',
                                nextNode: 'start'
                            },
                            {
                                text: "What exactly would I be getting into?",
                                heroLine: "Before I commit... what exactly would I be getting myself into here?",
                                npcResponse: "Portal stabilization. Dimensional resonance calibration. Possibly making contact with parallel realities. Standard Tuesday night stuff, really. Nothing to worry about. Probably.",
                                nextNode: 'hiring'
                            }
                        ]
                    },
                    portal_questions: {
                        options: [
                            {
                                text: "How dangerous is that thing?",
                                heroLine: "On a scale of 'paper cut' to 'unraveling the fabric of spacetime'... how dangerous are we talking?",
                                npcResponse: "Very. But in a manageable way. Like skydiving, except instead of falling you might get scattered across multiple dimensions. The containment field handles most of it though. Mostly.",
                                setFlag: 'asked_danger',
                                condition: (scene) => !scene.getFlag('asked_danger')
                            },
                            {
                                text: "Where does it lead?",
                                heroLine: "So where does it actually lead? Narnia? The Upside Down? A dimension where everyone has goatees?",
                                npcResponse: "Somewhere similar to here, but different. The readings suggest comparable physical laws, just... shifted slightly. Could be fascinating. Could be horrifying. That's science for you.",
                                setFlag: 'asked_destination',
                                condition: (scene) => !scene.getFlag('asked_destination')
                            },
                            {
                                text: "Has anyone gone through it?",
                                heroLine: "Has anyone ever... you know... gone through it? On purpose or otherwise?",
                                npcResponse: "Sent through some probes. Most came back. Got some interesting readings from the ones that didn't. Still working on the human trials. Volunteers have been... scarce.",
                                setFlag: 'asked_travel',
                                condition: (scene) => !scene.getFlag('asked_travel')
                            },
                            {
                                text: "What's special about tonight?",
                                heroLine: "What makes tonight special? Besides the obvious 'swirling portal in the living room' thing?",
                                npcResponse: "The frequency's been fluctuating for weeks - never could hold a stable connection. Tonight, for the first time, it's steady. If we lock it in now, we get a permanent bridge. That's never been done before. By anyone. Anywhere.",
                                setFlag: 'asked_breakthrough',
                                condition: (scene) => !scene.getFlag('asked_breakthrough')
                            },
                            {
                                text: "Let me ask about something else.",
                                heroLine: "Fascinating. And mildly terrifying. Let me ask about something else before my existential dread kicks in.",
                                npcResponse: "Fair enough. What else is on your mind?",
                                nextNode: 'start'
                            }
                        ]
                    },
                    tasks: {
                        options: [
                            {
                                text: "Red means holler, purple means run. Got it.",
                                heroLine: "Red means holler, purple means run. I think I can handle that. Probably.",
                                npcResponse: "That's the spirit. Cautious optimism. The official mood of fringe science. Now, the readings should stay in the green for a while. If they don't... well, we'll cross that bridge when we come to it. Or when it collapses.",
                                setFlag: 'accepted_task',
                                nextNode: 'start'
                            },
                            {
                                text: "What if things go really wrong?",
                                heroLine: "And if things go really wrong? Like, 'dimensional rift swallowing the house' wrong?",
                                npcResponse: "Then we improvise. I've got contingency plans for my contingency plans. And a fire extinguisher. You'd be surprised how often that last one comes in handy.",
                                nextNode: 'tasks'
                            }
                        ]
                    },
                    houseguests: {
                        options: [
                            {
                                text: "I saw something in the attic. With eyes.",
                                heroLine: "I thought I saw something in the attic. Something with... a lot of eyes? Please tell me that was a hallucination.",
                                npcResponse: "Oh, that's just the alien. Don't mind him - he's been crashing here for a while. Mostly just watches his shows. Very into soap operas. Gets surprisingly emotional about them.",
                                setFlag: 'asked_alien',
                                condition: (scene) => !scene.getFlag('asked_alien')
                            },
                            {
                                text: "Your neighbor seems... large. And furry.",
                                heroLine: "Your neighbor Earl seems... large. And furry. Is that just a style choice, or...?",
                                npcResponse: "Earl? Yeah, he's a bigfoot. Good guy though. We play chess on Thursdays. He's terrible at it, but he makes this amazing chili, so it evens out.",
                                setFlag: 'asked_earl',
                                condition: (scene) => !scene.getFlag('asked_earl')
                            },
                            {
                                text: "Anything in the basement I should know about?",
                                heroLine: "Is there anything in the basement I should know about? Or specifically avoid knowing about?",
                                npcResponse: "The basement is... a work in progress. Let's leave it at that for now. Nothing down there that concerns tonight's experiment. Probably best to just focus on the portal.",
                                setFlag: 'asked_basement',
                                condition: (scene) => !scene.getFlag('asked_basement')
                            },
                            {
                                text: "You know what? I'll just roll with it.",
                                heroLine: "You know what? I'm just going to roll with it. Aliens, bigfoots, mystery basements. This is fine.",
                                npcResponse: "That's the healthiest attitude, honestly. Questioning reality too hard can be exhausting. Better to just make coffee and keep going.",
                                nextNode: 'start'
                            }
                        ]
                    },
                    philosophy: {
                        options: [
                            {
                                text: "Don't other scientists give you a hard time?",
                                heroLine: "Don't the mainstream scientists give you a hard time? The whole 'mad scientist' stereotype and all?",
                                npcResponse: "Oh, constantly. They think I'm a crackpot. But I've got a working interdimensional portal in my basement-slash-laboratory, and they've got... peer review. I know which one I'd rather have.",
                                setFlag: 'asked_crazy',
                                condition: (scene) => !scene.getFlag('asked_crazy')
                            },
                            {
                                text: "Why this town specifically?",
                                heroLine: "Why here? What's special about this particular town for this kind of research?",
                                npcResponse: "This place has... unique properties. The readings here are off the charts. Scientifically speaking, it's one of the most interesting spots in New England. Also the rent is cheap. Both factors were important.",
                                setFlag: 'asked_origin',
                                condition: (scene) => !scene.getFlag('asked_origin')
                            },
                            {
                                text: "Any advice for a newcomer to fringe science?",
                                heroLine: "Any advice for someone just starting out in the 'science that might break reality' field?",
                                npcResponse: "Document everything. Trust your instruments more than your eyes. Never assume something is impossible. And always - always - keep a fire extinguisher within arm's reach. You'll thank me later.",
                                setFlag: 'asked_advice',
                                condition: (scene) => !scene.getFlag('asked_advice')
                            },
                            {
                                text: "Let me ask about something else.",
                                heroLine: "This is all great advice. Let me ask about something else before I get too philosophical.",
                                npcResponse: "Sure thing. Philosophy's fun, but it doesn't calibrate resonance arrays.",
                                nextNode: 'start'
                            }
                        ]
                    }
                };
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup for wide scrolling scene
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - bright warm amber laboratory lighting
                this.lights.enable();
                this.lights.setAmbientColor(0x8a7a6a); // Bright warm ambient

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 300;
                if (spawnPoint === 'from_house') spawnX = 250;
                else if (spawnPoint === 'right') spawnX = this.worldWidth - 200;

                this.createPlayer(spawnX, height * 0.80);

                // Create the scientist NPC
                this.createScientist(height);

                // Center camera on player
                this.cameras.main.scrollX = Phaser.Math.Clamp(
                    spawnX - this.screenWidth / 2, 0, this.worldWidth - this.screenWidth
                );

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('laboratory')) {
                    state.visitedRooms.push('laboratory');
                    this.setGameState(state);
                    this.showDialog("Well. This explains the electricity bill.");
                }
            }

            // Room-specific background - Mid Century Sci-Fi Laboratory
            drawRoom(worldWidth, height) {
                if (this.textures.exists('labBackground')) {
                    this.textures.remove('labBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Floor - industrial metal plates
                g.fillStyle(0x3a3a4a);
                g.fillRect(0, height * 0.72, worldWidth, height * 0.28);
                // Floor plate lines
                g.lineStyle(2, 0x2a2a3a, 0.6);
                for (let x = 0; x < worldWidth; x += 120) {
                    g.moveTo(x, height * 0.72);
                    g.lineTo(x, height);
                }
                for (let y = height * 0.80; y < height; y += 40) {
                    g.moveTo(0, y);
                    g.lineTo(worldWidth, y);
                }
                g.strokePath();
                // Floor rivets
                g.fillStyle(0x505060);
                for (let x = 60; x < worldWidth; x += 120) {
                    g.fillCircle(x, height * 0.76, 3);
                    g.fillCircle(x, height * 0.90, 3);
                }

                // Back wall - industrial panels
                g.fillStyle(0x4a4a5a);
                g.fillRect(0, 0, worldWidth, height * 0.72);
                // Wall panels
                g.fillStyle(0x3a3a4a);
                for (let x = 0; x < worldWidth; x += 200) {
                    g.fillRect(x + 5, height * 0.05, 190, height * 0.62);
                }
                // Panel borders
                g.lineStyle(2, 0x5a5a6a, 0.8);
                for (let x = 0; x < worldWidth; x += 200) {
                    g.strokeRect(x + 5, height * 0.05, 190, height * 0.62);
                }

                // Ceiling pipes
                g.fillStyle(0x606070);
                g.fillRect(0, height * 0.02, worldWidth, 15);
                g.fillStyle(0x707080);
                g.fillRect(0, 0, worldWidth, 8);
                // Pipe segments
                for (let x = 100; x < worldWidth; x += 300) {
                    g.fillStyle(0x505060);
                    g.fillRect(x, 0, 20, height * 0.15);
                }

                // === LEFT SECTION: Door and Chalkboard ===

                // Steel Door back to house
                g.fillStyle(0x5a5a5a);
                g.fillRect(100, height * 0.25, 100, height * 0.45);
                g.fillStyle(0x4a4a4a);
                g.fillRect(95, height * 0.23, 110, 12);
                g.fillRect(95, height * 0.23, 8, height * 0.49);
                g.fillRect(197, height * 0.23, 8, height * 0.49);
                // Door rivets
                g.fillStyle(0x707070);
                g.fillCircle(115, height * 0.30, 4);
                g.fillCircle(185, height * 0.30, 4);
                g.fillCircle(115, height * 0.65, 4);
                g.fillCircle(185, height * 0.65, 4);
                // Handle
                g.fillStyle(0x808080);
                g.fillRect(175, height * 0.48, 12, 25);

                // Chalkboard
                g.fillStyle(0x4a3a2a);
                g.fillRect(330, height * 0.18, 180, 140);
                g.fillStyle(0x2a4a3a);
                g.fillRect(340, height * 0.20, 160, 120);
                // Chalk equations
                g.lineStyle(2, 0xcccccc, 0.8);
                g.moveTo(355, height * 0.26);
                g.lineTo(400, height * 0.26);
                g.moveTo(410, height * 0.24);
                g.lineTo(430, height * 0.28);
                g.moveTo(355, height * 0.34);
                g.lineTo(480, height * 0.34);
                g.moveTo(360, height * 0.42);
                g.lineTo(420, height * 0.42);
                g.strokePath();
                // Chalk diagrams
                g.strokeCircle(450, height * 0.44, 20);
                g.moveTo(430, height * 0.44);
                g.lineTo(470, height * 0.44);

                // === LEFT-CENTER: Tesla Coil ===

                // Tesla coil base
                g.fillStyle(0x4a4a5a);
                g.fillRect(600, height * 0.55, 100, height * 0.17);
                g.fillStyle(0x606070);
                g.fillRect(590, height * 0.52, 120, 20);
                // Coil structure
                g.fillStyle(0x8b4513);
                g.fillRect(635, height * 0.20, 30, height * 0.35);
                // Coil windings
                g.lineStyle(3, 0xcd853f, 1);
                for (let y = height * 0.25; y < height * 0.52; y += 12) {
                    g.strokeRect(632, y, 36, 8);
                }
                // Top sphere
                g.fillStyle(0xc0c0c0);
                g.fillCircle(650, height * 0.18, 35);
                g.fillStyle(0xe0e0e0);
                g.fillCircle(640, height * 0.15, 12);

                // === CENTER: Portal Device ===

                // Portal frame base/pedestal
                g.fillStyle(0x4a4a5a);
                g.fillRect(1130, height * 0.60, 300, height * 0.12);
                g.fillStyle(0x5a5a6a);
                g.fillRect(1120, height * 0.57, 320, 20);

                // Portal outer frame
                g.fillStyle(0x6a6a7a);
                g.fillCircle(1280, height * 0.38, 160);
                g.fillStyle(0x5a5a6a);
                g.fillCircle(1280, height * 0.38, 145);
                // Inner ring
                g.fillStyle(0x7a7a8a);
                g.fillCircle(1280, height * 0.38, 130);
                // Portal void (will be enhanced with lighting)
                g.fillStyle(0x1a0a2a);
                g.fillCircle(1280, height * 0.38, 115);
                // Swirl effect (static part)
                g.lineStyle(4, 0x4a2a8a, 0.6);
                g.arc(1280, height * 0.38, 80, 0, Math.PI * 0.8);
                g.strokePath();
                g.lineStyle(3, 0x6a4aaa, 0.5);
                g.arc(1280, height * 0.38, 60, Math.PI * 0.5, Math.PI * 1.5);
                g.strokePath();
                g.lineStyle(2, 0x8a6aca, 0.4);
                g.arc(1280, height * 0.38, 40, Math.PI, Math.PI * 2.2);
                g.strokePath();
                // Frame details - bolts
                g.fillStyle(0x808090);
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                    const bx = 1280 + Math.cos(angle) * 150;
                    const by = height * 0.38 + Math.sin(angle) * 150;
                    g.fillCircle(bx, by, 8);
                }
                // Support struts
                g.fillStyle(0x4a4a5a);
                g.fillRect(1140, height * 0.55, 30, height * 0.10);
                g.fillRect(1390, height * 0.55, 30, height * 0.10);

                // Cables from portal to floor
                g.lineStyle(8, 0x3a3a4a, 1);
                g.moveTo(1150, height * 0.60);
                g.lineTo(1100, height * 0.72);
                g.moveTo(1410, height * 0.60);
                g.lineTo(1460, height * 0.72);
                g.strokePath();

                // === RIGHT-CENTER: Equipment Shelf ===

                // Shelf unit
                g.fillStyle(0x5a4a3a);
                g.fillRect(1720, height * 0.25, 180, height * 0.47);
                // Shelves
                g.fillStyle(0x6a5a4a);
                for (let y = height * 0.32; y < height * 0.70; y += height * 0.12) {
                    g.fillRect(1725, y, 170, 8);
                }
                // Beakers and bottles
                const bottleColors = [0x4a9a4a, 0x9a4a9a, 0x4a4a9a, 0x9a9a4a, 0x9a4a4a];
                for (let shelf = 0; shelf < 3; shelf++) {
                    for (let i = 0; i < 4; i++) {
                        const bx = 1745 + i * 40;
                        const by = height * 0.30 + shelf * height * 0.12;
                        g.fillStyle(0xcccccc);
                        g.fillRect(bx, by - 30, 20, 30);
                        g.fillStyle(bottleColors[(shelf + i) % bottleColors.length]);
                        g.fillRect(bx + 2, by - 25, 16, 20);
                    }
                }
                // Brain jar (because mad scientist)
                g.fillStyle(0xaaaaaa);
                g.fillRect(1870, height * 0.38, 25, 40);
                g.fillStyle(0x88ccaa);
                g.fillRect(1872, height * 0.40, 21, 35);
                g.fillStyle(0xddaaaa);
                g.fillCircle(1882, height * 0.48, 8);

                // === FAR RIGHT: Control Terminal ===

                // Main console body
                g.fillStyle(0x4a4a5a);
                g.fillRect(2000, height * 0.35, 250, height * 0.37);
                g.fillStyle(0x5a5a6a);
                g.fillRect(1990, height * 0.32, 270, 20);
                // Screen
                g.fillStyle(0x1a2a1a);
                g.fillRect(2020, height * 0.38, 150, 90);
                g.fillStyle(0x2a4a2a);
                g.fillRect(2025, height * 0.40, 140, 80);
                // Screen text lines (green terminal style)
                g.lineStyle(2, 0x40ff40, 0.8);
                for (let i = 0; i < 4; i++) {
                    const lineLen = 60 + Math.random() * 60;
                    g.moveTo(2035, height * 0.43 + i * 18);
                    g.lineTo(2035 + lineLen, height * 0.43 + i * 18);
                }
                g.strokePath();
                // Blinking cursor
                g.fillStyle(0x40ff40);
                g.fillRect(2035, height * 0.53, 8, 12);

                // Button panel
                g.fillStyle(0x3a3a4a);
                g.fillRect(2020, height * 0.58, 210, 60);
                // Buttons
                const buttonColors = [0xff4040, 0x40ff40, 0x4040ff, 0xffff40, 0xff40ff, 0x40ffff];
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 6; col++) {
                        g.fillStyle(buttonColors[col]);
                        g.fillCircle(2045 + col * 32, height * 0.60 + row * 25, 8);
                    }
                }
                // Levers
                g.fillStyle(0x808080);
                g.fillRect(2180, height * 0.40, 15, 60);
                g.fillRect(2210, height * 0.45, 15, 55);
                g.fillStyle(0xff4040);
                g.fillCircle(2187, height * 0.38, 10);
                g.fillStyle(0x40ff40);
                g.fillCircle(2217, height * 0.43, 10);

                // Cables on floor (simple polylines)
                g.lineStyle(6, 0x2a2a3a, 0.8);
                g.moveTo(2050, height * 0.72);
                g.lineTo(1900, height * 0.78);
                g.lineTo(1700, height * 0.76);
                g.lineTo(1500, height * 0.72);
                g.strokePath();
                g.lineStyle(4, 0x3a2a2a, 0.8);
                g.moveTo(700, height * 0.72);
                g.lineTo(900, height * 0.80);
                g.lineTo(1100, height * 0.77);
                g.lineTo(1200, height * 0.72);
                g.strokePath();

                // Wall-mounted lights
                for (let x = 300; x < worldWidth; x += 400) {
                    g.fillStyle(0x606070);
                    g.fillRect(x - 15, height * 0.08, 30, 20);
                    g.fillStyle(0xffdd88);
                    g.fillRect(x - 10, height * 0.12, 20, 12);
                }

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('labBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'labBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            // Room-specific lighting
            createLighting(worldWidth, height) {
                // Main overhead lights - warm amber
                this.overheadLights = [];
                for (let x = 300; x < worldWidth; x += 400) {
                    const light = this.lights.addLight(x, height * 0.15, 400, 0xffdd88, 1.2);
                    this.overheadLights.push(light);
                }

                // Portal glow - blue/purple ethereal
                this.portalLight = this.lights.addLight(1280, height * 0.38, 300, 0x8866ff, 1.5);
                this.portalLightInner = this.lights.addLight(1280, height * 0.38, 150, 0xaa88ff, 1.0);

                // Tesla coil glow - electric blue
                this.teslaLight = this.lights.addLight(650, height * 0.30, 200, 0x88aaff, 0.8);

                // Terminal glow - green
                this.terminalLight = this.lights.addLight(2100, height * 0.50, 180, 0x44ff44, 0.6);

                // Equipment shelf warm light
                this.shelfLight = this.lights.addLight(1810, height * 0.45, 150, 0xffaa66, 0.5);

                // Portal bloom effects
                this.portalBloom = this.add.graphics();
                this.portalBloom.setDepth(5);
                this.drawPortalBloom(height);

                // Tesla spark effect container
                this.teslaSparks = this.add.graphics();
                this.teslaSparks.setDepth(6);
            }

            drawPortalBloom(height) {
                this.portalBloom.clear();
                // Multiple layers for soft glow
                const layers = [
                    { radius: 140, alpha: 0.05, color: 0x8866ff },
                    { radius: 130, alpha: 0.08, color: 0x9977ff },
                    { radius: 120, alpha: 0.12, color: 0xaa88ff },
                    { radius: 110, alpha: 0.15, color: 0xbb99ff }
                ];
                layers.forEach(layer => {
                    this.portalBloom.fillStyle(layer.color, layer.alpha);
                    this.portalBloom.fillCircle(1280, height * 0.38, layer.radius);
                });
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                console.log('[Lab] executeAction:', action, hotspot.name);
                if (action === 'Use') {
                    if (hotspot.name === 'Door to House') {
                        this.transitionToScene('GameScene', 'from_lab');
                    } else {
                        this.showDialog(hotspot.useResponse);
                    }
                } else if (action === 'Look At') {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Talk To') {
                    console.log('[Lab] Talk To action on:', hotspot.name);
                    if (hotspot.name === 'Dr. Manzana') {
                        console.log('[Lab] Starting scientist conversation...');
                        this.startScientistConversation();
                    } else {
                        this.showDialog(hotspot.talkResponse);
                    }
                }
            }

            startScientistConversation() {
                console.log('[Lab] startScientistConversation called');
                console.log('[Lab] this.scientist:', this.scientist);
                const npcData = {
                    name: 'Hector',
                    x: this.scientist.x,
                    y: this.scientist.y
                };
                console.log('[Lab] npcData:', npcData);
                const dialogue = this.getScientistDialogue();
                console.log('[Lab] dialogue:', dialogue);
                this.enterConversation(npcData, dialogue);
            }

            createScientist(height) {
                // Create scientist sprite container at the terminal - Dr. Hector Manzana
                // Using same pixel art style as the hero
                this.scientist = this.add.container(2050, height * 0.68);
                this.scientist.setDepth(100);

                const p = 6; // Pixel size (same as hero)
                const pixel = (x, y, color) => {
                    const sprite = this.add.sprite(x * p, -y * p, 'pixel');
                    sprite.setTint(color);
                    sprite.setPipeline('Light2D');
                    return sprite;
                };

                // Colors for Hector
                const SKIN = 0xd4a574, SKIN_DARK = 0xb8956a;
                const HAIR = 0x1a1a1a, HAIR_GRAY = 0x606060;
                const COAT = 0xeeeeee, COAT_DARK = 0xcccccc;
                const PANTS = 0x2c3e50, PANTS_DARK = 0x1a252f;
                const SHOES = 0x1a1a1a, BLACK = 0x000000, WHITE = 0xffffff;
                const MUSTACHE = 0x2a2a2a;
                const GOGGLE_FRAME = 0x3a3a3a, GOGGLE_LENS = 0x88ccff;

                const pixels = [];

                // Shoes (y: 0-1)
                for (let x = -5; x <= -2; x++) { pixels.push(pixel(x, 0, SHOES)); pixels.push(pixel(x, 1, SHOES)); }
                for (let x = 2; x <= 5; x++) { pixels.push(pixel(x, 0, SHOES)); pixels.push(pixel(x, 1, SHOES)); }

                // Legs (y: 2-18) - dark trousers
                for (let y = 2; y <= 18; y++) {
                    for (let x = -4; x <= -2; x++) pixels.push(pixel(x, y, x === -4 ? PANTS_DARK : PANTS));
                    for (let x = 2; x <= 4; x++) pixels.push(pixel(x, y, x === 4 ? PANTS_DARK : PANTS));
                }

                // Lab coat body (y: 18-30)
                for (let y = 18; y <= 30; y++) {
                    for (let x = -5; x <= 5; x++) {
                        if (x === -5 || x === 5) pixels.push(pixel(x, y, COAT_DARK));
                        else if (x === 0 && y >= 20) pixels.push(pixel(x, y, COAT_DARK)); // Center seam
                        else pixels.push(pixel(x, y, COAT));
                    }
                }
                // Coat collar
                for (let x = -4; x <= 4; x++) pixels.push(pixel(x, 31, COAT));
                pixels.push(pixel(-3, 32, COAT)); pixels.push(pixel(3, 32, COAT));

                // Arms in lab coat (y: 19-28)
                for (let y = 19; y <= 27; y++) {
                    pixels.push(pixel(-6, y, COAT)); pixels.push(pixel(-7, y, COAT_DARK));
                    pixels.push(pixel(6, y, COAT)); pixels.push(pixel(7, y, COAT_DARK));
                }

                // Hands (y: 19-21)
                for (let y = 19; y <= 21; y++) {
                    pixels.push(pixel(-8, y, SKIN)); pixels.push(pixel(-9, y, SKIN_DARK));
                    pixels.push(pixel(8, y, SKIN)); pixels.push(pixel(9, y, SKIN_DARK));
                }

                // Neck (y: 32-33)
                for (let i = 0; i < 2; i++) for (let x = -1; x <= 1; x++) pixels.push(pixel(x, 32 + i, SKIN));

                // Head (y: 34-42)
                for (let y = 34; y <= 42; y++) {
                    let w = y >= 37 && y <= 39 ? 5 : (y >= 36 && y <= 40 ? 4 : 3);
                    for (let x = -w; x <= w; x++) pixels.push(pixel(x, y, (x === -w || x === w) ? SKIN_DARK : SKIN));
                }

                // Eyes (y: 38-40)
                [-3, -2].forEach(x => { pixels.push(pixel(x, 38, BLACK)); pixels.push(pixel(x, 39, BLACK)); });
                [2, 3].forEach(x => { pixels.push(pixel(x, 38, BLACK)); pixels.push(pixel(x, 39, BLACK)); });
                pixels.push(pixel(-3, 39, WHITE)); pixels.push(pixel(2, 39, WHITE));
                // Eyebrows
                for (let x = -4; x <= -1; x++) pixels.push(pixel(x, 40, BLACK));
                for (let x = 1; x <= 4; x++) pixels.push(pixel(x, 40, BLACK));

                // Nose hint
                pixels.push(pixel(0, 37, SKIN_DARK));

                // Mustache (y: 35-36)
                for (let x = -3; x <= 3; x++) pixels.push(pixel(x, 36, MUSTACHE));
                pixels.push(pixel(-4, 36, MUSTACHE)); pixels.push(pixel(4, 36, MUSTACHE));
                for (let x = -2; x <= 2; x++) pixels.push(pixel(x, 35, MUSTACHE));

                // Hair - slick black with gray on sides (y: 41-47)
                // Main black hair on top
                for (let y = 41; y <= 45; y++) {
                    let w = y >= 44 ? 3 : (y >= 43 ? 4 : 4);
                    if (y === 45) w = 2;
                    for (let x = -w; x <= w; x++) {
                        pixels.push(pixel(x, y, (x === -w || x === w || y === 45) ? HAIR : HAIR));
                    }
                }
                // Slicked back top
                pixels.push(pixel(-1, 46, HAIR)); pixels.push(pixel(0, 46, HAIR)); pixels.push(pixel(1, 46, HAIR));
                pixels.push(pixel(0, 47, HAIR));

                // Gray hair on sides (distinguished look)
                for (let y = 41; y <= 43; y++) {
                    pixels.push(pixel(-5, y, HAIR_GRAY));
                    pixels.push(pixel(5, y, HAIR_GRAY));
                }

                // Goggles pushed up on forehead (y: 43-44)
                pixels.push(pixel(-4, 44, GOGGLE_FRAME)); pixels.push(pixel(-3, 44, GOGGLE_LENS)); pixels.push(pixel(-2, 44, GOGGLE_LENS));
                pixels.push(pixel(-4, 43, GOGGLE_FRAME)); pixels.push(pixel(-3, 43, GOGGLE_LENS)); pixels.push(pixel(-2, 43, GOGGLE_FRAME));
                pixels.push(pixel(4, 44, GOGGLE_FRAME)); pixels.push(pixel(3, 44, GOGGLE_LENS)); pixels.push(pixel(2, 44, GOGGLE_LENS));
                pixels.push(pixel(4, 43, GOGGLE_FRAME)); pixels.push(pixel(3, 43, GOGGLE_LENS)); pixels.push(pixel(2, 43, GOGGLE_FRAME));
                // Goggle strap
                pixels.push(pixel(-1, 44, GOGGLE_FRAME)); pixels.push(pixel(0, 44, GOGGLE_FRAME)); pixels.push(pixel(1, 44, GOGGLE_FRAME));

                pixels.forEach(px => this.scientist.add(px));
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Portal Device') {
                    this.showDialog(`Toss the ${item.name} into a swirling void? Tempting, but I might need that later.`);
                } else if (hotspot.name === 'Control Terminal') {
                    this.showDialog(`No slot for a ${item.name}. These old machines, so picky about their inputs.`);
                } else if (hotspot.name === 'Tesla Coil') {
                    this.showDialog(`The ${item.name} and high voltage? That's how you get a very ex-${item.name}.`);
                } else {
                    this.showDialog(`Not sure what that would accomplish, but I admire the creativity.`);
                }
            }

            update() {
                super.update();

                const { height } = this.scale;
                const time = this.time.now * 0.001;

                // Portal pulsing effect
                if (this.portalLight) {
                    const portalPulse = Math.sin(time * 2) * 0.3 + Math.sin(time * 3.7) * 0.15;
                    this.portalLight.intensity = 1.5 + portalPulse;
                    this.portalLightInner.intensity = 1.0 + portalPulse * 0.5;

                    // Update bloom opacity
                    this.portalBloom.clear();
                    const bloomAlpha = 0.12 + portalPulse * 0.05;
                    const layers = [
                        { radius: 140, alpha: bloomAlpha * 0.4 },
                        { radius: 130, alpha: bloomAlpha * 0.6 },
                        { radius: 120, alpha: bloomAlpha * 0.8 },
                        { radius: 110, alpha: bloomAlpha }
                    ];
                    layers.forEach((layer, i) => {
                        const color = 0x8866ff + (i * 0x111100);
                        this.portalBloom.fillStyle(color, layer.alpha);
                        this.portalBloom.fillCircle(1280, height * 0.38, layer.radius);
                    });
                }

                // Tesla coil crackle
                if (this.teslaLight) {
                    const teslaCrackle = Math.sin(time * 15) * 0.3 + Math.sin(time * 23) * 0.2;
                    this.teslaLight.intensity = 0.8 + teslaCrackle;

                    // Random spark effect
                    this.teslaSparks.clear();
                    if (Math.random() > 0.7) {
                        this.teslaSparks.lineStyle(2, 0x88ccff, 0.8);
                        const sparkAngle = Math.random() * Math.PI * 2;
                        const sparkLen = 30 + Math.random() * 40;
                        const sx = 650 + Math.cos(sparkAngle) * 35;
                        const sy = height * 0.18 + Math.sin(sparkAngle) * 35;
                        this.teslaSparks.moveTo(sx, sy);
                        this.teslaSparks.lineTo(
                            sx + Math.cos(sparkAngle) * sparkLen,
                            sy + Math.sin(sparkAngle) * sparkLen
                        );
                        this.teslaSparks.strokePath();
                    }
                }

                // Terminal screen flicker
                if (this.terminalLight) {
                    const termFlicker = Math.sin(time * 8) * 0.1 + Math.sin(time * 13) * 0.05;
                    this.terminalLight.intensity = 0.6 + termFlicker;
                }

                // Subtle overhead light flicker
                if (this.overheadLights) {
                    this.overheadLights.forEach((light, i) => {
                        const flicker = Math.sin(time * 4 + i) * 0.05 + Math.sin(time * 7 + i * 2) * 0.03;
                        light.intensity = 1.2 + flicker;
                    });
                }
            }
        }

        // ============================================================================
        // BACKYARD SCENE - Backyard at Night with Neighbor (extends BaseScene)
        // ============================================================================
        class BackyardScene extends BaseScene {
            constructor() {
                super({ key: 'BackyardScene' });
                this.worldWidth = 1920; // 1.5x screen width
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.68, maxY: 0.92 };
                this.neighborVisible = false;
                this.neighborSprite = null;
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                const hotspots = [
                    {
                        x: 150, y: height * 0.45, w: 100, h: height * 0.35,
                        interactX: 220, interactY: height * 0.78,
                        name: 'Back Door',
                        verbLabels: { actionVerb: 'Open', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "The door back into the house. Warm light spills out through the glass.",
                        useResponse: "TRANSITION_TO_HOUSE",
                        talkResponse: "Thanks for letting me out here, door. I needed some air."
                    },
                    {
                        x: 960, y: height * 0.78, w: 300, h: height * 0.14,
                        interactX: 960, interactY: height * 0.82,
                        name: 'Lawn',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Grass. Slightly overgrown, but it's nice to be outside. The night air is refreshing.",
                        useResponse: "I run my hand through the cool grass. Damp from the evening dew.",
                        talkResponse: "Hey grass. Keep up the good work."
                    },
                    {
                        x: 600, y: height * 0.65, w: 80, h: height * 0.20,
                        interactX: 600, interactY: height * 0.78,
                        name: 'Garden Gnome',
                        verbLabels: { actionVerb: 'Pick up', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A garden gnome with a knowing smirk. It's seen things. Things it's not telling.",
                        useResponse: "It's surprisingly heavy. And... is it glaring at me? I'll leave it.",
                        talkResponse: "What do you know, little gnome? ...Nothing? That's what they all say."
                    },
                    {
                        x: 1700, y: height * 0.40, w: 200, h: height * 0.35,
                        interactX: 1600, interactY: height * 0.78,
                        name: 'Fence',
                        isNPC: true,
                        verbLabels: { actionVerb: 'Climb', lookVerb: 'Examine', talkVerb: 'Call out' },
                        lookResponse: "A tall wooden fence. I can see warm string lights glowing over the top. Looks cozy over there.",
                        useResponse: "I could probably climb it, but that seems rude. Maybe I should just say hello?",
                        talkResponse: "START_NEIGHBOR_CONVERSATION"
                    }
                ];

                // Gate is now an edge zone, not a hotspot (created in createEdgeZones)

                return hotspots;
            }

            // Neighbor dialogue tree
            getNeighborDialogue() {
                return {
                    start: {
                        options: [
                            {
                                text: "Who are you?",
                                heroLine: "Oh! Hello there. I didn't expect... anyone. Who are you?",
                                npcResponse: "Name's Earl! Earl Henderson. Been living next door for... oh, must be twenty years now. Longer than most of the folks who've lived in that house, I'll tell you that much.",
                                setFlag: 'neighbor_asked_who',
                                condition: (scene) => !scene.getFlag('neighbor_asked_who')
                            },
                            {
                                text: "Nice night, huh?",
                                heroLine: "Nice night out, huh?",
                                npcResponse: "Sure is! Perfect for sitting on the porch with a cold one. The stars are real pretty tonight. Don't get nights like this in the city, I'll tell you that.",
                                setFlag: 'neighbor_asked_weather',
                                condition: (scene) => !scene.getFlag('neighbor_asked_weather')
                            },
                            {
                                text: "Tell me about this house.",
                                heroLine: "So... what can you tell me about this house?",
                                npcResponse: "Oh, the old place? It's got history, that one. Been through a lot of owners. Scientists, artists, one fella who collected... well, strange things. Real strange things.",
                                nextNode: 'house_questions',
                                setFlag: 'neighbor_asked_house'
                            },
                            {
                                text: "Those lights look cozy.",
                                heroLine: "I couldn't help but notice those string lights. Looks really cozy over there.",
                                npcResponse: "Oh, I put those up myself! Makes the backyard feel like a little slice of paradise. Plus I can find my way to the cooler without a flashlight, heh heh!",
                                setFlag: 'neighbor_asked_lights',
                                condition: (scene) => !scene.getFlag('neighbor_asked_lights'),
                                nextNode: 'beer_path'
                            },
                            {
                                text: "I should get going.",
                                heroLine: "Well, it was nice meeting you. I should probably head back inside.",
                                npcResponse: "Don't be a stranger now! I'm usually out here most evenings. Holler if you need anything!",
                                exit: true
                            }
                        ]
                    },
                    house_questions: {
                        options: [
                            {
                                text: "Strange things?",
                                heroLine: "What kind of strange things?",
                                npcResponse: "Oh, you know... glowing rocks, humming machines, that kind of stuff. He'd have deliveries at all hours. Big metal crates. Never did find out what happened to him. Just... gone one day.",
                                setFlag: 'neighbor_asked_strange',
                                condition: (scene) => !scene.getFlag('neighbor_asked_strange')
                            },
                            {
                                text: "Any weird occurrences?",
                                heroLine: "Has anything... weird ever happened around here?",
                                npcResponse: "Weird? Well, there was that one time the power went out in the whole neighborhood, but just for a second. And the sky turned this funny color. Purple, I think. But that was probably just a storm, right?",
                                setFlag: 'neighbor_asked_weird',
                                condition: (scene) => !scene.getFlag('neighbor_asked_weird')
                            },
                            {
                                text: "Who lives here now?",
                                heroLine: "Who owns the place now?",
                                npcResponse: "Some scientist fella moved in a few years back. Keeps to himself mostly. Nice enough when you catch him outside. Bit scattered, if you know what I mean. Always talking about 'breakthroughs' and such.",
                                setFlag: 'neighbor_asked_owner',
                                condition: (scene) => !scene.getFlag('neighbor_asked_owner')
                            },
                            {
                                text: "Let's talk about something else.",
                                heroLine: "Interesting. What else can you tell me?",
                                npcResponse: "What else would you like to know?",
                                nextNode: 'start'
                            }
                        ]
                    },
                    beer_path: {
                        options: [
                            {
                                text: "Sounds like paradise indeed.",
                                heroLine: "A slice of paradise sounds pretty good right about now.",
                                npcResponse: "You know what? Why don't you come on over! I've got cold ones in the cooler and I just made a fresh batch of my famous chili. There's a gate in the fence right there - just give it a push!",
                                setFlag: 'neighbor_invited_over',
                                action: 'SHOW_GATE',
                                exit: true
                            },
                            {
                                text: "I'm more of an indoors person.",
                                heroLine: "Sounds nice, but I'm more of an indoors person myself.",
                                npcResponse: "To each their own! But if you ever change your mind, you know where to find me. Usually right here, enjoying the evening.",
                                nextNode: 'start'
                            }
                        ]
                    }
                };
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup for scrolling scene
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - moonlit exterior with warm glow from neighbor's yard
                this.lights.enable();
                this.lights.setAmbientColor(0x3a4a5a); // Cool moonlit ambient

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create edge zones for scene transitions (gate to neighbor's yard)
                this.createEdgeZones(height);

                // If returning after invitation, draw the gate visual
                if (this.getFlag('neighbor_invited_over')) {
                    this.drawGate(height);
                }

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 300;
                if (spawnPoint === 'from_house') spawnX = 250;
                else if (spawnPoint === 'right') spawnX = this.worldWidth - 200;
                else if (spawnPoint === 'from_neighbor') spawnX = this.worldWidth - 200;

                this.createPlayer(spawnX, height * 0.80);

                // Create neighbor sprite (hidden initially unless flag is set)
                this.createNeighbor(height);

                // Center camera on player
                this.cameras.main.scrollX = Phaser.Math.Clamp(
                    spawnX - this.screenWidth / 2, 0, this.worldWidth - this.screenWidth
                );

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('backyard')) {
                    state.visitedRooms.push('backyard');
                    this.setGameState(state);
                    this.showDialog("Ah, the backyard. Nice to get some fresh air. And those lights over the fence look inviting...");
                }
            }

            // Room-specific background - Backyard at night
            drawRoom(worldWidth, height) {
                if (this.textures.exists('backyardBackground')) {
                    this.textures.remove('backyardBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Night sky gradient
                g.fillStyle(0x0a0a1a);
                g.fillRect(0, 0, worldWidth, height * 0.45);
                g.fillStyle(0x101025);
                g.fillRect(0, height * 0.25, worldWidth, height * 0.20);

                // Stars
                g.fillStyle(0xffffff);
                const starPositions = [
                    [100, 40], [250, 80], [400, 30], [550, 90], [700, 50],
                    [850, 70], [1000, 25], [1150, 85], [1300, 45], [1450, 95],
                    [1600, 35], [1750, 75], [1850, 55], [150, 120], [450, 110],
                    [750, 130], [1050, 115], [1350, 105], [1650, 125], [1900, 60]
                ];
                starPositions.forEach(([x, y]) => {
                    const size = Math.random() > 0.7 ? 2 : 1;
                    g.fillCircle(x, y, size);
                });

                // Moon (upper left)
                g.fillStyle(0xeeeedd);
                g.fillCircle(250, 100, 35);
                g.fillStyle(0xddddcc);
                g.fillCircle(240, 95, 7);
                g.fillCircle(260, 105, 5);

                // === LEFT SECTION: House Back Wall and Door ===

                // House back wall
                g.fillStyle(0x3a3a4a);
                g.fillRect(0, height * 0.15, 300, height * 0.60);

                // Back door (glass-paned)
                g.fillStyle(0x4a3020);
                g.fillRect(100, height * 0.25, 100, height * 0.45);
                // Glass panes showing warm interior
                g.fillStyle(0x4a3a2a);
                g.fillRect(110, height * 0.28, 35, height * 0.15);
                g.fillRect(155, height * 0.28, 35, height * 0.15);
                g.fillRect(110, height * 0.47, 35, height * 0.15);
                g.fillRect(155, height * 0.47, 35, height * 0.15);
                // Warm glow from inside
                g.fillStyle(0x6a5a3a, 0.7);
                g.fillRect(112, height * 0.30, 31, height * 0.12);
                g.fillRect(157, height * 0.30, 31, height * 0.12);
                // Door handle
                g.fillStyle(0xc0a060);
                g.fillCircle(185, height * 0.52, 5);
                g.lineStyle(2, 0x2a1808, 1);
                g.strokeRect(100, height * 0.25, 100, height * 0.45);

                // Back steps
                g.fillStyle(0x5a4a3a);
                g.fillRect(80, height * 0.70, 140, 15);
                g.fillStyle(0x4a3a2a);
                g.fillRect(70, height * 0.72, 160, 15);
                g.fillStyle(0x3a2a1a);
                g.fillRect(60, height * 0.74, 180, 12);

                // House wall texture - siding
                g.lineStyle(1, 0x2a2a3a, 0.3);
                for (let y = height * 0.18; y < height * 0.75; y += 15) {
                    g.moveTo(0, y);
                    g.lineTo(300, y);
                }
                g.strokePath();

                // Window on house wall
                g.fillStyle(0x1a1a2a);
                g.fillRect(220, height * 0.30, 60, 50);
                g.fillStyle(0x5a4a3a, 0.5);
                g.fillRect(223, height * 0.32, 25, 22);
                g.fillRect(252, height * 0.32, 25, 22);
                g.lineStyle(2, 0x4a3a2a, 1);
                g.strokeRect(220, height * 0.30, 60, 50);

                // === CENTER SECTION: Grass and Garden ===

                // Grass ground
                g.fillStyle(0x1a3a1a);
                g.fillRect(0, height * 0.72, worldWidth, height * 0.28);
                // Grass texture variation
                g.fillStyle(0x152a15);
                for (let x = 0; x < worldWidth; x += 40) {
                    g.fillRect(x, height * 0.72, 20, height * 0.28);
                }

                // Garden gnome
                g.fillStyle(0x8a4a3a);
                g.fillCircle(600, height * 0.68, 20); // Body
                g.fillStyle(0xe8c4a0);
                g.fillCircle(600, height * 0.62, 12); // Face
                g.fillStyle(0xcc2222);
                g.fillTriangle(600, height * 0.50, 585, height * 0.60, 615, height * 0.60); // Hat
                g.fillStyle(0xffffff);
                g.fillCircle(595, height * 0.61, 3); // Eye
                g.fillCircle(605, height * 0.61, 3); // Eye
                g.fillStyle(0x4a4a4a);
                g.fillCircle(596, height * 0.61, 1.5);
                g.fillCircle(606, height * 0.61, 1.5);

                // Some bushes in the center
                g.fillStyle(0x1a4a1a);
                g.fillCircle(450, height * 0.70, 30);
                g.fillCircle(480, height * 0.68, 25);
                g.fillCircle(420, height * 0.71, 20);
                g.fillStyle(0x2a5a2a);
                g.fillCircle(460, height * 0.67, 18);

                // More bushes near fence
                g.fillStyle(0x1a4a1a);
                g.fillCircle(1300, height * 0.70, 35);
                g.fillCircle(1350, height * 0.68, 28);
                g.fillCircle(1260, height * 0.71, 22);

                // === RIGHT SECTION: Fence with String Lights ===

                // Fence posts and planks
                g.fillStyle(0x5a4a3a);
                for (let x = 1400; x < worldWidth; x += 80) {
                    // Fence planks
                    g.fillRect(x, height * 0.32, 75, height * 0.43);
                }
                // Fence post caps
                g.fillStyle(0x4a3a2a);
                for (let x = 1400; x < worldWidth; x += 80) {
                    g.fillRect(x - 3, height * 0.30, 81, 12);
                }
                // Fence texture - wood grain
                g.lineStyle(1, 0x3a2a1a, 0.5);
                for (let x = 1400; x < worldWidth; x += 80) {
                    g.moveTo(x + 37, height * 0.32);
                    g.lineTo(x + 37, height * 0.75);
                }
                g.strokePath();

                // Gate in fence (only visible if invited)
                // Will be drawn as hotspot overlay when needed

                // String lights ABOVE the fence (visible glow from neighbor's yard)
                // The lights themselves
                g.fillStyle(0xffeeaa);
                const lightPositions = [
                    [1450, height * 0.26], [1520, height * 0.24], [1590, height * 0.27],
                    [1660, height * 0.25], [1730, height * 0.26], [1800, height * 0.24],
                    [1870, height * 0.27]
                ];
                lightPositions.forEach(([lx, ly]) => {
                    g.fillCircle(lx, ly, 6);
                });

                // String between lights
                g.lineStyle(2, 0x2a2a2a, 0.8);
                g.moveTo(1420, height * 0.25);
                lightPositions.forEach(([lx, ly]) => {
                    g.lineTo(lx, ly - 4);
                });
                g.lineTo(1920, height * 0.25);
                g.strokePath();

                // Warm glow above fence (neighbor's yard atmosphere)
                g.fillStyle(0x3a3520, 0.3);
                g.fillRect(1400, height * 0.12, worldWidth - 1400, height * 0.20);

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('backyardBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'backyardBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            createLighting(worldWidth, height) {
                // Main moonlight - cool blue
                this.moonLight = this.lights.addLight(250, 100, 500, 0x8899cc, 0.8);
                // Moon fill
                this.moonFill = this.lights.addLight(600, height * 0.40, 700, 0x6677aa, 0.35);

                // Warm light spilling from house door
                this.doorLight = this.lights.addLight(150, height * 0.50, 300, 0xffaa66, 0.9);

                // Window light
                this.windowLight = this.lights.addLight(250, height * 0.38, 150, 0xffcc88, 0.5);

                // String lights glow - warm yellow/orange
                this.stringLights = [];
                const lightXPositions = [1450, 1520, 1590, 1660, 1730, 1800, 1870];
                lightXPositions.forEach((lx, i) => {
                    const light = this.lights.addLight(lx, height * 0.26, 120, 0xffdd88, 0.7);
                    this.stringLights.push(light);
                });

                // General warm glow from neighbor's yard spilling over
                this.neighborGlow = this.lights.addLight(1700, height * 0.35, 400, 0xffcc77, 0.4);

                // Ground fill for visibility
                this.groundFill = this.lights.addLight(960, height * 0.85, 800, 0x5566aa, 0.2);

                this.createLightBloom(height);
            }

            createLightBloom(height) {
                // Moon glow
                const moonBloom = this.add.graphics();
                moonBloom.fillStyle(0x8899cc, 0.08);
                moonBloom.fillCircle(0, 0, 80);
                moonBloom.setPosition(250, 100);
                moonBloom.setBlendMode(Phaser.BlendModes.ADD);
                moonBloom.setDepth(1);

                // Door warm glow
                const doorBloom = this.add.graphics();
                doorBloom.fillStyle(0xffaa66, 0.1);
                doorBloom.fillCircle(0, 0, 100);
                doorBloom.setPosition(150, height * 0.52);
                doorBloom.setBlendMode(Phaser.BlendModes.ADD);
                doorBloom.setDepth(1);

                // String light blooms
                this.stringLightBlooms = [];
                const lightXPositions = [1450, 1520, 1590, 1660, 1730, 1800, 1870];
                lightXPositions.forEach((lx, i) => {
                    const bloom = this.add.graphics();
                    bloom.fillStyle(0xffee99, 0.15);
                    bloom.fillCircle(0, 0, 25);
                    bloom.setPosition(lx, height * 0.26);
                    bloom.setBlendMode(Phaser.BlendModes.ADD);
                    bloom.setDepth(1);
                    this.stringLightBlooms.push(bloom);
                });
            }

            createNeighbor(height) {
                // Check if neighbor has been talked to before
                if (this.getFlag('neighbor_appeared')) {
                    this.showNeighborSprite(height);
                }
            }

            showNeighborSprite(height) {
                if (this.neighborSprite) return; // Already shown

                // Create neighbor sprite - Wilson style (just eyes and top of hat visible above fence)
                this.neighborSprite = this.add.container(1700, height * 0.30);
                this.neighborSprite.setDepth(150);

                const g = this.add.graphics();

                // Top of hat (visible above fence)
                g.fillStyle(0x4a6a4a); // Green fishing/hunting hat
                g.fillRect(-25, -10, 50, 15);
                g.fillStyle(0x3a5a3a);
                g.fillRect(-30, 5, 60, 8); // Hat brim

                // Eyes peeking over fence
                g.fillStyle(0xe8c4a0); // Skin
                g.fillRect(-20, 12, 40, 20); // Forehead area visible

                // Eyes
                g.fillStyle(0xffffff);
                g.fillCircle(-8, 22, 8);
                g.fillCircle(8, 22, 8);
                g.fillStyle(0x4a6a8a); // Blue-gray eyes
                g.fillCircle(-8, 22, 4);
                g.fillCircle(8, 22, 4);
                g.fillStyle(0x000000);
                g.fillCircle(-8, 22, 2);
                g.fillCircle(8, 22, 2);

                // Bushy eyebrows
                g.fillStyle(0x6a6a6a);
                g.fillRect(-15, 12, 14, 4);
                g.fillRect(1, 12, 14, 4);

                this.neighborSprite.add(g);

                // Add slight animation - neighbor sways slightly
                this.tweens.add({
                    targets: this.neighborSprite,
                    y: height * 0.30 + 3,
                    duration: 2000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                this.neighborVisible = true;
            }

            hideNeighborSprite() {
                if (this.neighborSprite) {
                    this.neighborSprite.destroy();
                    this.neighborSprite = null;
                    this.neighborVisible = false;
                }
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                const height = this.scale.height;

                if (action === 'Use') {
                    if (hotspot.name === 'Back Door') {
                        this.transitionToScene('GameScene', 'from_backyard');
                    } else if (hotspot.name === 'Gate') {
                        this.showDialog(hotspot.useResponse);
                    } else {
                        this.showDialog(hotspot.useResponse);
                    }
                } else if (action === 'Look At') {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Talk To') {
                    if (hotspot.name === 'Fence') {
                        // First time talking - neighbor appears
                        if (!this.getFlag('neighbor_appeared')) {
                            this.setFlag('neighbor_appeared', true);
                            // Nate calls out first
                            this.showDialog("Hello? Anyone over there?", () => {
                                // Neighbor pops up
                                this.showNeighborSprite(height);
                                // Start conversation with Earl's greeting
                                this.startNeighborConversation(true);
                            });
                        } else {
                            // Already talked before - just start conversation
                            this.startNeighborConversation(false);
                        }
                    } else {
                        this.showDialog(hotspot.talkResponse);
                    }
                }
            }

            startNeighborConversation(showGreeting = false) {
                const height = this.scale.height;
                const npcData = {
                    name: 'Earl',
                    x: 1700,
                    y: height * 0.50  // Position for speech bubble calc (y - 280 = above fence)
                };
                const dialogue = this.getNeighborDialogue();

                if (showGreeting) {
                    // Set up conversation state first
                    this.conversationActive = true;
                    this.conversationNPC = npcData;
                    this.conversationData = dialogue;
                    this.conversationState = 'start';
                    this.stopCharacterMovement();
                    if (this.verbCoin) this.verbCoin.setVisible(false);
                    this.verbCoinVisible = false;
                    if (this.crosshairCursor) this.crosshairCursor.setVisible(true);
                    this.drawCrosshair(0xffffff);

                    // Show Earl's greeting, then show options
                    this.showConversationLine("Well hello there, neighbor! Don't think I've seen you around before!", 'npc', () => {
                        this.showDialogueOptions('start');
                    });
                } else {
                    this.enterConversation(npcData, dialogue);
                }
            }

            handleDialogueChoice(option, currentNode) {
                // Store the action to execute after conversation exits
                if (option.action === 'SHOW_GATE') {
                    this.pendingAction = 'SHOW_GATE';
                }
                // Call parent handler with both parameters
                super.handleDialogueChoice(option, currentNode);
            }

            exitConversation() {
                // Check for pending actions before exiting
                if (this.pendingAction === 'SHOW_GATE') {
                    // Show gate visual (this also creates the edge zone for transitioning)
                    this.drawGate(this.scale.height);
                    // Hide the neighbor
                    this.hideNeighborSprite();
                    this.pendingAction = null;
                }
                // Call parent exit
                super.exitConversation();
            }

            drawGate(height) {
                // Add gate visual to the fence - positioned to the RIGHT of where hero stands
                const gateX = 1750;

                // Warm light spilling through the open gate
                const glow = this.add.graphics();
                glow.fillStyle(0xffcc66, 0.3);
                glow.fillRect(gateX + 10, height * 0.35, 40, height * 0.40);
                glow.fillStyle(0xffaa44, 0.2);
                glow.fillRect(gateX + 15, height * 0.38, 30, height * 0.34);
                glow.setDepth(4);
                glow.setBlendMode(Phaser.BlendModes.ADD);

                // The gap in the fence (dark opening)
                const opening = this.add.graphics();
                opening.fillStyle(0x1a2a1a);
                opening.fillRect(gateX + 5, height * 0.32, 50, height * 0.43);
                opening.setPipeline('Light2D');
                opening.setDepth(3);

                // The gate door itself - slightly ajar/angled
                const gate = this.add.graphics();
                // Gate frame
                gate.fillStyle(0x5a4a3a);
                gate.fillRect(gateX + 45, height * 0.33, 15, height * 0.41);
                // Gate planks (vertical boards)
                gate.fillStyle(0x6a5a4a);
                gate.fillRect(gateX + 48, height * 0.35, 10, height * 0.37);
                // Gate details
                gate.lineStyle(1, 0x4a3a2a, 0.8);
                gate.moveTo(gateX + 53, height * 0.35);
                gate.lineTo(gateX + 53, height * 0.72);
                gate.strokePath();
                // Hinges
                gate.fillStyle(0x3a3a3a);
                gate.fillRect(gateX + 55, height * 0.38, 6, 8);
                gate.fillRect(gateX + 55, height * 0.62, 6, 8);
                gate.setPipeline('Light2D');
                gate.setDepth(5);

                // Add a light source for the warm glow from neighbor's yard
                this.gateLight = this.lights.addLight(gateX + 30, height * 0.50, 150, 0xffaa55, 0.8);

                // Brief flash effect to draw attention
                const flash = this.add.graphics();
                flash.fillStyle(0xffffcc, 0.4);
                flash.fillRect(gateX, height * 0.30, 70, height * 0.45);
                flash.setDepth(10);
                flash.setBlendMode(Phaser.BlendModes.ADD);

                // Fade out the flash
                this.tweens.add({
                    targets: flash,
                    alpha: 0,
                    duration: 800,
                    ease: 'Power2',
                    onComplete: () => flash.destroy()
                });

                // Create the edge zone for the gate after it appears
                this.createGateEdgeZone(height);
            }

            // Edge zones for scene transitions
            createEdgeZones(height) {
                // Gate edge zone only appears after neighbor invites you over
                if (this.getFlag('neighbor_invited_over')) {
                    // Gate visual should already exist from drawGate
                    this.createGateEdgeZone(height);
                }
            }

            createGateEdgeZone(height) {
                // Destroy existing gate edge zone if any
                if (this.gateEdgeZone) {
                    this.gateEdgeZone.destroy();
                }

                const gateX = 1750;

                // Create the edge zone at the gate location
                this.gateEdgeZone = this.add.zone(gateX + 30, height * 0.55, 80, height * 0.35)
                    .setInteractive()
                    .setOrigin(0.5);

                this.gateEdgeZone.on('pointerover', () => {
                    if (!this.inventoryOpen && !this.verbCoinVisible) {
                        this.edgeHovered = 'right';
                        this.showArrowCursor('right');
                    }
                });

                this.gateEdgeZone.on('pointerout', () => {
                    this.edgeHovered = null;
                    this.hideArrowCursor();
                });

                this.gateEdgeZone.on('pointerdown', (pointer) => {
                    if (this.inventoryOpen) return;

                    // Prevent main input handler from overriding our walk
                    this.clickedUI = true;

                    const currentTime = Date.now();
                    const isDoubleClick = (currentTime - (this.edgeClickTime || 0)) < 300;
                    this.edgeClickTime = currentTime;

                    if (isDoubleClick) {
                        // Immediate transition
                        this.hideArrowCursor();
                        this.transitionToScene('NeighborYardScene', 'from_backyard');
                    } else {
                        // Walk to gate then transition
                        this.hideArrowCursor();
                        this.walkToEdgeAndTransition(gateX, height * 0.80, 'NeighborYardScene', 'from_backyard');
                    }
                });
            }

            walkToEdgeAndTransition(targetX, targetY, scene, spawnPoint) {
                this.walkTo(targetX, targetY, () => {
                    this.transitionToScene(scene, spawnPoint);
                }, false);
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Garden Gnome') {
                    this.showDialog(`The gnome doesn't seem interested in my ${item.name}. Judgmental little guy.`);
                } else if (hotspot.name === 'Fence') {
                    this.showDialog(`I don't think throwing my ${item.name} over the fence would help anything.`);
                } else {
                    this.showDialog(`That doesn't work.`);
                }
            }

            update() {
                super.update();

                // String lights gentle flicker
                const time = this.time.now * 0.001;
                if (this.stringLights) {
                    this.stringLights.forEach((light, i) => {
                        const flicker = Math.sin(time * 3 + i * 1.5) * 0.1 + Math.sin(time * 7 + i) * 0.05;
                        light.intensity = 0.7 + flicker;
                    });
                }

                if (this.stringLightBlooms) {
                    this.stringLightBlooms.forEach((bloom, i) => {
                        const flicker = Math.sin(time * 3 + i * 1.5) * 0.1;
                        bloom.setAlpha(0.12 + flicker * 0.5);
                    });
                }
            }
        }

        // ============================================================================
        // NEIGHBOR YARD SCENE - Earl's Backyard BBQ (extends BaseScene)
        // ============================================================================
        class NeighborYardScene extends BaseScene {
            constructor() {
                super({ key: 'NeighborYardScene' });
                this.worldWidth = 1280; // Single screen, no scrolling
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.70, maxY: 0.92 };
                this.earlSprite = null;
            }

            // Room-specific hotspot data
            getHotspotData(height) {
                return [
                    {
                        x: 655, y: height * 0.52, w: 90, h: height * 0.22,
                        interactX: 580, interactY: height * 0.78,
                        name: 'Grill',
                        verbLabels: { actionVerb: 'Use', lookVerb: 'Examine', talkVerb: 'Sniff' },
                        lookResponse: "A classic Weber kettle grill. Earl's got some serious looking burgers sizzling away. The smell is incredible.",
                        useResponse: "I shouldn't mess with another man's grill. That's like... sacred territory.",
                        talkResponse: "*sniff sniff* Oh man, that smells good. Real charcoal, none of that propane nonsense."
                    },
                    {
                        x: 190, y: height * 0.55, w: 80, h: height * 0.20,
                        interactX: 280, interactY: height * 0.78,
                        name: 'Lawn Chair',
                        verbLabels: { actionVerb: 'Sit', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A well-worn aluminum lawn chair with woven straps. The kind that leaves a pattern on your legs if you sit too long.",
                        useResponse: "I settle into the chair. It's surprisingly comfortable. I could get used to this.",
                        talkResponse: "Hey chair. You've seen some things, haven't you? Some real backyard moments."
                    },
                    {
                        x: 950, y: height * 0.55, w: 60, h: height * 0.20,
                        interactX: 880, interactY: height * 0.78,
                        name: 'Plastic Flamingo',
                        verbLabels: { actionVerb: 'Pick up', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A pink plastic flamingo, standing proudly on one leg. It's seen better days, but it's got character.",
                        useResponse: "Earl might notice if his flamingo went missing. Better leave it.",
                        talkResponse: "Hey there, pinky. Keeping the yard safe from... whatever plastic flamingos guard against."
                    },
                    {
                        x: 1100, y: height * 0.55, w: 70, h: height * 0.20,
                        interactX: 1030, interactY: height * 0.78,
                        name: 'Vintage Radio',
                        verbLabels: { actionVerb: 'Tune', lookVerb: 'Examine', talkVerb: 'Listen' },
                        lookResponse: "A beautiful mid-century radio, the kind with real wood and that warm tube sound. Soft oldies music drifts from the speaker.",
                        useResponse: "I fiddle with the dial. Nothing but static and... is that 'Fly Me to the Moon'? Classic.",
                        talkResponse: "The radio croons softly about love and summer nights. Good stuff."
                    },
                    {
                        x: 400, y: height * 0.50, w: 250, h: height * 0.35,
                        interactX: 400, interactY: height * 0.78,
                        name: 'Mobile Home',
                        verbLabels: { actionVerb: 'Enter', lookVerb: 'Examine', talkVerb: 'Knock' },
                        lookResponse: "Earl's mobile home. It's small but cozy-looking, with warm light glowing from the windows. Very homey.",
                        useResponse: "I should probably be invited in first. Can't just barge into a neighbor's home.",
                        talkResponse: "*knock knock* No answer. Earl's out here at the grill anyway."
                    },
                    {
                        x: 750, y: height * 0.45, w: 100, h: height * 0.35,
                        interactX: 650, interactY: height * 0.78,
                        name: 'Earl',
                        isNPC: true,
                        verbLabels: { actionVerb: 'Approach', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Earl Henderson. He's... well, he's definitely a bigfoot. Standing about 7 feet tall, covered in reddish-brown fur, wearing a chef's hat and a 'Kiss the Cook' apron. He seems completely at ease.",
                        useResponse: "I'm not sure what that would accomplish.",
                        talkResponse: "START_EARL_CONVERSATION"
                    }
                ];
            }

            // Earl's dialogue tree
            getEarlDialogue() {
                return {
                    start: {
                        options: [
                            {
                                text: "Nice place you got here.",
                                heroLine: "This is a really nice setup you've got here, Earl.",
                                npcResponse: "Thanks, neighbor! Been workin' on it for years. Little slice of paradise, I like to say. Nothing fancy, but it's home.",
                                setFlag: 'earl_complimented_yard',
                                condition: (scene) => !scene.getFlag('earl_complimented_yard')
                            },
                            {
                                text: "What's on the grill?",
                                heroLine: "Those burgers smell amazing. What's your secret?",
                                npcResponse: "Ah, just a little seasoning, bit of Worcestershire, and the key - real hardwood charcoal. None of that briquette business. You gotta treat the meat with respect, you know?",
                                nextNode: 'grilling_tips',
                                setFlag: 'earl_asked_grill'
                            },
                            {
                                text: "So... you're a bigfoot.",
                                heroLine: "So, I hope this isn't rude, but... you're a bigfoot?",
                                npcResponse: "Sasquatch, technically. 'Bigfoot' is more of a media thing. But yeah, guilty as charged! Been one my whole life, heh heh.",
                                nextNode: 'bigfoot_questions',
                                setFlag: 'earl_asked_bigfoot',
                                condition: (scene) => !scene.getFlag('earl_asked_bigfoot')
                            },
                            {
                                text: "Tell me about the neighborhood.",
                                heroLine: "What's the neighborhood like around here?",
                                npcResponse: "Pretty quiet, mostly. Good folks. The Hendersons down the street - no relation - they keep to themselves. Old Mrs. Patterson's got a mean casserole recipe. And of course, your house has always been... interesting.",
                                nextNode: 'neighborhood_talk',
                                setFlag: 'earl_asked_neighborhood'
                            },
                            {
                                text: "I should head back.",
                                heroLine: "Well, thanks for having me over. I should probably get back.",
                                npcResponse: "Anytime, neighbor! Door's always open. Well, gate's always open. You know what I mean. Don't be a stranger!",
                                exit: true
                            }
                        ]
                    },
                    grilling_tips: {
                        options: [
                            {
                                text: "Any other tips?",
                                heroLine: "Got any other grilling wisdom to share?",
                                npcResponse: "Don't press the patties! Everyone wants to squish 'em, but that's just pushing all the juice out. Let 'em be. Patience is key.",
                                setFlag: 'earl_tip_patties',
                                condition: (scene) => !scene.getFlag('earl_tip_patties')
                            },
                            {
                                text: "Where'd you learn to cook?",
                                heroLine: "Where'd you learn to grill like this?",
                                npcResponse: "Self-taught, mostly. Spent a lot of years in the woods, cooking over campfires. You learn to appreciate good food when you've eaten raw fish for a decade. Not recommended, by the way.",
                                setFlag: 'earl_cooking_history',
                                condition: (scene) => !scene.getFlag('earl_cooking_history')
                            },
                            {
                                text: "Back to other topics.",
                                heroLine: "Let me ask about something else.",
                                npcResponse: "Sure thing! What's on your mind?",
                                nextNode: 'start'
                            }
                        ]
                    },
                    bigfoot_questions: {
                        options: [
                            {
                                text: "How long have you lived here?",
                                heroLine: "How long have you been living... you know, among regular people?",
                                npcResponse: "Oh, about thirty years now. Settled down after I got tired of the nomadic life. Turns out, indoor plumbing is a game-changer. Who knew?",
                                setFlag: 'earl_history',
                                condition: (scene) => !scene.getFlag('earl_history')
                            },
                            {
                                text: "Don't people... notice?",
                                heroLine: "Don't people notice that you're, well, a seven-foot-tall sasquatch?",
                                npcResponse: "You'd be surprised what people don't notice when they're busy with their own lives. Plus, I tell 'em I have a glandular condition. Works every time.",
                                setFlag: 'earl_noticed',
                                condition: (scene) => !scene.getFlag('earl_noticed')
                            },
                            {
                                text: "Any other cryptids around?",
                                heroLine: "Are there... other creatures like you around here?",
                                npcResponse: "Here and there. There's a chupacabra runs the laundromat two towns over. Real nice guy. And I'm pretty sure the mailman is a werewolf, but he's never said anything directly.",
                                setFlag: 'earl_cryptids',
                                condition: (scene) => !scene.getFlag('earl_cryptids')
                            },
                            {
                                text: "Back to other topics.",
                                heroLine: "Let me ask about something else.",
                                npcResponse: "Fire away, neighbor!",
                                nextNode: 'start'
                            }
                        ]
                    },
                    neighborhood_talk: {
                        options: [
                            {
                                text: "What do you mean, 'interesting'?",
                                heroLine: "What do you mean my house has been 'interesting'?",
                                npcResponse: "Oh, nothing bad! Just... the previous owners always had weird stuff going on. Lights at odd hours, strange deliveries, that whole 'secret laboratory in the basement' thing. You know how it is.",
                                setFlag: 'earl_house_history',
                                condition: (scene) => !scene.getFlag('earl_house_history')
                            },
                            {
                                text: "Who lived there before?",
                                heroLine: "Do you remember who lived in my house before me?",
                                npcResponse: "Let's see... there was that scientist fella, real eccentric type. Before him, an artist who painted nothing but doors. And before that, someone who claimed to be a time traveler. Nice guy, always knew the weather in advance.",
                                setFlag: 'earl_previous_owners',
                                condition: (scene) => !scene.getFlag('earl_previous_owners')
                            },
                            {
                                text: "Any neighborhood events?",
                                heroLine: "Does the neighborhood do any events? Block parties, that kind of thing?",
                                npcResponse: "Oh sure! We used to do potlucks. I'd bring my famous venison chili - secret family recipe. Folks stopped asking where I got the venison, which I appreciated.",
                                setFlag: 'earl_events',
                                condition: (scene) => !scene.getFlag('earl_events')
                            },
                            {
                                text: "Back to other topics.",
                                heroLine: "Let me ask about something else.",
                                npcResponse: "What else you wanna know?",
                                nextNode: 'start'
                            }
                        ]
                    }
                };
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup (no scrolling for this scene)
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - warm backyard evening atmosphere
                this.lights.enable();
                this.lights.setAmbientColor(0x4a3a2a); // Warm amber ambient

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create edge zones for scene transitions
                this.createEdgeZones(height);

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 100;
                if (spawnPoint === 'from_backyard') spawnX = 100;

                this.createPlayer(spawnX, height * 0.80);

                // Create Earl at the grill
                this.createEarl(height);

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('neighbor_yard')) {
                    state.visitedRooms.push('neighbor_yard');
                    this.setGameState(state);
                    this.showDialog("Earl's backyard. Cozy. The grill smells amazing and those tiki lights give the whole place a warm, festive feel.");
                }
            }

            // Room-specific background - Earl's backyard
            drawRoom(worldWidth, height) {
                if (this.textures.exists('neighborYardBackground')) {
                    this.textures.remove('neighborYardBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Night sky gradient
                g.fillStyle(0x0a0a1a);
                g.fillRect(0, 0, worldWidth, height * 0.40);
                g.fillStyle(0x101025);
                g.fillRect(0, height * 0.22, worldWidth, height * 0.18);

                // Stars
                g.fillStyle(0xffffff);
                const starPositions = [
                    [80, 35], [180, 70], [320, 25], [450, 80], [580, 40],
                    [720, 65], [850, 30], [980, 75], [1100, 45], [1200, 60],
                    [140, 90], [380, 50], [620, 85], [900, 55], [1050, 95]
                ];
                starPositions.forEach(([x, y]) => {
                    const size = Math.random() > 0.7 ? 2 : 1;
                    g.fillCircle(x, y, size);
                });

                // === LEFT SECTION: Gate back to your yard ===
                // Fence on left side (boundary back to player's yard)
                g.fillStyle(0x5a4a3a);
                for (let x = 0; x < 120; x += 80) {
                    g.fillRect(x, height * 0.35, 75, height * 0.40);
                }
                g.fillStyle(0x4a3a2a);
                for (let x = 0; x < 120; x += 80) {
                    g.fillRect(x - 3, height * 0.33, 81, 12);
                }
                // Gate opening
                g.fillStyle(0x1a2a1a);
                g.fillRect(20, height * 0.36, 50, height * 0.38);

                // === CENTER-LEFT: Mobile Home ===
                // Mobile home body
                g.fillStyle(0x6a7a7a);
                g.fillRect(250, height * 0.25, 350, height * 0.45);
                // Roof
                g.fillStyle(0x4a5a5a);
                g.fillRect(240, height * 0.22, 370, height * 0.06);
                // Windows (glowing warm)
                g.fillStyle(0x2a3a3a);
                g.fillRect(280, height * 0.32, 60, 50);
                g.fillRect(380, height * 0.32, 60, 50);
                g.fillRect(480, height * 0.32, 60, 50);
                // Window glow
                g.fillStyle(0x6a5a3a, 0.8);
                g.fillRect(283, height * 0.34, 54, 44);
                g.fillRect(383, height * 0.34, 54, 44);
                g.fillRect(483, height * 0.34, 54, 44);
                // Door
                g.fillStyle(0x4a3020);
                g.fillRect(320, height * 0.45, 40, height * 0.25);
                g.fillStyle(0xc0a060);
                g.fillCircle(350, height * 0.58, 4);
                // Steps
                g.fillStyle(0x5a5a5a);
                g.fillRect(310, height * 0.70, 60, 12);

                // Metal siding lines
                g.lineStyle(1, 0x5a6a6a, 0.5);
                for (let y = height * 0.28; y < height * 0.70; y += 15) {
                    g.moveTo(250, y);
                    g.lineTo(600, y);
                }
                g.strokePath();

                // === CENTER: Grass ===
                g.fillStyle(0x1a3a1a);
                g.fillRect(0, height * 0.72, worldWidth, height * 0.28);
                // Grass texture
                g.fillStyle(0x152a15);
                for (let x = 0; x < worldWidth; x += 50) {
                    g.fillRect(x, height * 0.72, 25, height * 0.28);
                }

                // === CENTER: Weber Grill ===
                const grillX = 655;
                const grillBaseY = height * 0.72; // Ground level
                // Grill legs (tripod style)
                g.fillStyle(0x2a2a2a);
                g.fillRect(grillX - 35, grillBaseY - 50, 6, 50);
                g.fillRect(grillX + 30, grillBaseY - 50, 6, 50);
                g.fillRect(grillX - 3, grillBaseY - 45, 6, 45);
                // Grill bowl (bottom half of kettle)
                g.fillStyle(0x1a1a1a);
                g.fillRect(grillX - 40, grillBaseY - 80, 80, 35);
                g.fillStyle(0x2a2a2a);
                g.fillRect(grillX - 38, grillBaseY - 78, 76, 5);
                // Grill lid (dome)
                g.fillStyle(0x1a1a1a);
                g.fillRect(grillX - 38, grillBaseY - 115, 76, 35);
                g.fillStyle(0x2a2a2a);
                g.fillRect(grillX - 35, grillBaseY - 118, 70, 8);
                // Handle on top
                g.fillStyle(0x5a3a2a);
                g.fillRect(grillX - 5, grillBaseY - 130, 10, 15);
                // Vent holes
                g.fillStyle(0x3a3a3a);
                g.fillRect(grillX - 25, grillBaseY - 70, 8, 4);
                g.fillRect(grillX + 17, grillBaseY - 70, 8, 4);

                // === RIGHT SIDE: Decorations ===
                // Lawn chair (aluminum folding style)
                const chairX = 190;
                const chairY = height * 0.72;
                g.fillStyle(0x8a8a8a); // Aluminum frame
                // Back legs
                g.fillRect(chairX - 25, chairY - 80, 4, 80);
                g.fillRect(chairX + 35, chairY - 80, 4, 80);
                // Seat frame
                g.fillRect(chairX - 25, chairY - 45, 64, 4);
                // Webbing (seat)
                g.fillStyle(0x3a8aaa);
                for (let i = 0; i < 5; i++) {
                    g.fillRect(chairX - 22 + i * 12, chairY - 43, 10, 25);
                }
                // Webbing (back)
                for (let i = 0; i < 5; i++) {
                    g.fillRect(chairX - 22 + i * 12, chairY - 78, 10, 30);
                }
                // Arm rests
                g.fillStyle(0x8a8a8a);
                g.fillRect(chairX - 28, chairY - 50, 6, 4);
                g.fillRect(chairX + 36, chairY - 50, 6, 4);

                // Plastic flamingo
                const flamingoX = 950;
                const flamingoY = height * 0.72;
                // Single leg (wire)
                g.fillStyle(0x333333);
                g.fillRect(flamingoX, flamingoY - 55, 2, 55);
                // Body
                g.fillStyle(0xff69b4);
                g.fillCircle(flamingoX, flamingoY - 65, 18);
                g.fillCircle(flamingoX + 5, flamingoY - 70, 12);
                // Neck (curved)
                g.fillRect(flamingoX + 8, flamingoY - 95, 6, 30);
                // Head
                g.fillCircle(flamingoX + 11, flamingoY - 100, 8);
                // Beak
                g.fillStyle(0x1a1a1a);
                g.fillTriangle(flamingoX + 11, flamingoY - 100, flamingoX - 5, flamingoY - 102, flamingoX + 11, flamingoY - 98);
                // Eye
                g.fillStyle(0x000000);
                g.fillCircle(flamingoX + 14, flamingoY - 101, 2);

                // Vintage radio on small table
                const radioX = 1100;
                const radioY = height * 0.72;
                // Table
                g.fillStyle(0x5a4a3a);
                g.fillRect(radioX - 20, radioY - 40, 70, 8);
                g.fillRect(radioX - 15, radioY - 40, 6, 40);
                g.fillRect(radioX + 40, radioY - 40, 6, 40);
                // Radio body
                g.fillStyle(0x6a4a2a);
                g.fillRect(radioX - 15, radioY - 75, 60, 35);
                // Radio face (dial area)
                g.fillStyle(0xddc080);
                g.fillRect(radioX - 10, radioY - 70, 35, 25);
                // Dial markings
                g.fillStyle(0x4a3a2a);
                g.fillRect(radioX - 5, radioY - 65, 25, 2);
                g.fillRect(radioX + 5, radioY - 60, 2, 10);
                // Speaker grille
                g.fillStyle(0x4a3a2a);
                g.fillRect(radioX + 30, radioY - 70, 12, 25);
                g.lineStyle(1, 0x5a4a3a);
                for (let i = 0; i < 5; i++) {
                    g.moveTo(radioX + 32, radioY - 68 + i * 5);
                    g.lineTo(radioX + 40, radioY - 68 + i * 5);
                }
                g.strokePath();
                // Knobs
                g.fillStyle(0x3a2a1a);
                g.fillCircle(radioX, radioY - 48, 5);
                g.fillCircle(radioX + 30, radioY - 48, 5);

                // === STRING LIGHTS (Tiki style - colorful) ===
                // Main string across the yard
                g.lineStyle(2, 0x3a3a3a, 0.8);
                g.moveTo(100, height * 0.22);
                const stringY = [0.20, 0.18, 0.20, 0.19, 0.21, 0.18, 0.20, 0.19];
                const stringX = [200, 350, 500, 650, 800, 950, 1100, 1200];
                stringX.forEach((x, i) => {
                    g.lineTo(x, height * stringY[i]);
                });
                g.strokePath();

                // String from mobile home
                g.moveTo(600, height * 0.22);
                g.lineTo(700, height * 0.25);
                g.lineTo(850, height * 0.23);
                g.lineTo(1000, height * 0.26);
                g.lineTo(1150, height * 0.24);
                g.strokePath();

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('neighborYardBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'neighborYardBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            createLighting(worldWidth, height) {
                // Main ambient from mobile home windows
                this.windowLight = this.lights.addLight(400, height * 0.45, 250, 0xffcc88, 1.0);

                // Grill glow
                this.grillLight = this.lights.addLight(655, height * 0.58, 120, 0xff6633, 0.9);

                // Tiki string lights - colorful!
                this.tikiBlooms = [];
                this.tikiLights = [];
                const tikiColors = [
                    0xff4444, 0xffaa33, 0x44ff44, 0x4444ff,
                    0xff44ff, 0xffff44, 0x44ffff, 0xff8844
                ];
                const tikiPositions = [
                    [200, height * 0.20], [350, height * 0.18], [500, height * 0.20],
                    [650, height * 0.19], [800, height * 0.21], [950, height * 0.18],
                    [1100, height * 0.20], [700, height * 0.25], [850, height * 0.23],
                    [1000, height * 0.26]
                ];

                tikiPositions.forEach((pos, i) => {
                    const color = tikiColors[i % tikiColors.length];
                    // Light source
                    const light = this.lights.addLight(pos[0], pos[1], 80, color, 0.6);
                    this.tikiLights.push(light);

                    // Bloom effect
                    const bloom = this.add.graphics();
                    bloom.fillStyle(color, 0.15);
                    bloom.fillCircle(pos[0], pos[1], 12);
                    bloom.fillStyle(color, 0.25);
                    bloom.fillCircle(pos[0], pos[1], 6);
                    bloom.setBlendMode(Phaser.BlendModes.ADD);
                    bloom.setDepth(10);
                    this.tikiBlooms.push({ bloom, color, x: pos[0], y: pos[1] });
                });

                // Create smoke particles for grill
                this.createGrillSmoke(height);
            }

            createGrillSmoke(height) {
                // Animated smoke rising from grill
                this.smokeParticles = [];
                for (let i = 0; i < 5; i++) {
                    const smoke = this.add.graphics();
                    smoke.fillStyle(0xaaaaaa, 0.3);
                    smoke.fillCircle(0, 0, 8 + Math.random() * 8);
                    smoke.setPosition(655 + (Math.random() - 0.5) * 30, height * 0.45);
                    smoke.setDepth(8);
                    smoke.setBlendMode(Phaser.BlendModes.ADD);
                    this.smokeParticles.push({
                        graphic: smoke,
                        baseX: 655,
                        baseY: height * 0.45,
                        offset: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.3
                    });
                }
            }

            createEarl(height) {
                // Earl - Sam & Max style bigfoot: chunky, cartoony, friendly
                // Position him next to the grill, feet on the ground
                const earlX = 750;
                const earlY = height * 0.72; // Ground level

                this.earlSprite = this.add.container(earlX, earlY);
                const p = 5; // Pixel size

                const pixel = (x, y, color) => {
                    const rect = this.add.rectangle(x * p, -y * p, p, p, color);
                    rect.setOrigin(0.5);
                    return rect;
                };

                // Sam & Max style colors - warm reddish-brown fur
                const FUR = 0x8B4513;
                const FUR_LIGHT = 0xA0522D;
                const FUR_DARK = 0x5D3A1A;
                const FUR_SHADE = 0x4A2A10;
                const FACE = 0x6B4423;
                const NOSE = 0x2a1a0a;
                const EYES = 0x1a1a1a;
                const EYE_WHITE = 0xfafafa;
                const APRON = 0xf0f0f0;
                const APRON_SHADE = 0xd0d0d0;
                const HEART = 0xdd3333;
                const HAT = 0xffffff;
                const HAT_SHADE = 0xe8e8e8;
                const SPATULA_METAL = 0x888888;
                const SPATULA_HANDLE = 0x4a3020;

                const pixels = [];

                // === BIG FURRY FEET (y: 0-6) ===
                // Left foot
                for (let x = -8; x <= -2; x++) {
                    for (let y = 0; y <= 3; y++) {
                        pixels.push(pixel(x, y, y === 0 ? FUR_SHADE : FUR_DARK));
                    }
                }
                // Right foot
                for (let x = 2; x <= 8; x++) {
                    for (let y = 0; y <= 3; y++) {
                        pixels.push(pixel(x, y, y === 0 ? FUR_SHADE : FUR_DARK));
                    }
                }

                // === THICK LEGS (y: 4-18) ===
                for (let y = 4; y <= 18; y++) {
                    // Left leg - chunky
                    for (let x = -7; x <= -2; x++) {
                        const shade = (x === -7 || x === -2) ? FUR_DARK : ((y % 4 < 2) ? FUR : FUR_LIGHT);
                        pixels.push(pixel(x, y, shade));
                    }
                    // Right leg - chunky
                    for (let x = 2; x <= 7; x++) {
                        const shade = (x === 2 || x === 7) ? FUR_DARK : ((y % 4 < 2) ? FUR : FUR_LIGHT);
                        pixels.push(pixel(x, y, shade));
                    }
                }

                // === LOWER BODY WITH APRON (y: 19-35) ===
                for (let y = 19; y <= 35; y++) {
                    const bodyWidth = y < 25 ? 9 : (y < 30 ? 10 : 9);
                    for (let x = -bodyWidth; x <= bodyWidth; x++) {
                        // Apron in front (narrower than body)
                        if (x >= -5 && x <= 5 && y >= 19 && y <= 32) {
                            pixels.push(pixel(x, y, (x === -5 || x === 5) ? APRON_SHADE : APRON));
                        } else {
                            // Fur on sides
                            const shade = (Math.abs(x) === bodyWidth) ? FUR_DARK : ((y % 3 === 0) ? FUR_LIGHT : FUR);
                            pixels.push(pixel(x, y, shade));
                        }
                    }
                }

                // === HEART ON APRON (y: 24-29) - "Kiss the Cook" ===
                const heartPixels = [
                    [-2, 28], [-1, 28], [1, 28], [2, 28],
                    [-3, 27], [-2, 27], [-1, 27], [0, 27], [1, 27], [2, 27], [3, 27],
                    [-3, 26], [-2, 26], [-1, 26], [0, 26], [1, 26], [2, 26], [3, 26],
                    [-2, 25], [-1, 25], [0, 25], [1, 25], [2, 25],
                    [-1, 24], [0, 24], [1, 24],
                    [0, 23]
                ];
                heartPixels.forEach(([hx, hy]) => pixels.push(pixel(hx, hy, HEART)));

                // === UPPER BODY / SHOULDERS (y: 36-48) ===
                for (let y = 36; y <= 48; y++) {
                    const shoulderWidth = y < 40 ? 10 : (y < 44 ? 11 : 10);
                    for (let x = -shoulderWidth; x <= shoulderWidth; x++) {
                        const shade = (Math.abs(x) >= shoulderWidth - 1) ? FUR_DARK : ((y % 3 === 0) ? FUR_LIGHT : FUR);
                        pixels.push(pixel(x, y, shade));
                    }
                }

                // === APRON STRAPS (over shoulders) ===
                for (let y = 33; y <= 46; y++) {
                    pixels.push(pixel(-4, y, APRON));
                    pixels.push(pixel(-3, y, APRON_SHADE));
                    pixels.push(pixel(4, y, APRON_SHADE));
                    pixels.push(pixel(5, y, APRON));
                }
                // Strap goes behind neck
                for (let x = -3; x <= 4; x++) {
                    pixels.push(pixel(x, 47, APRON_SHADE));
                }

                // === ARMS (y: 38-50) ===
                // Left arm - hanging
                for (let y = 36; y <= 50; y++) {
                    for (let x = -13; x <= -10; x++) {
                        pixels.push(pixel(x, y, (x === -13) ? FUR_DARK : FUR));
                    }
                }
                // Left hand/paw
                for (let x = -14; x <= -10; x++) {
                    for (let y = 32; y <= 36; y++) {
                        pixels.push(pixel(x, y, FACE));
                    }
                }

                // Right arm - holding spatula, bent
                for (let y = 36; y <= 48; y++) {
                    for (let x = 10; x <= 13; x++) {
                        pixels.push(pixel(x, y, (x === 13) ? FUR_DARK : FUR));
                    }
                }
                // Right hand holding spatula
                for (let x = 12; x <= 16; x++) {
                    for (let y = 42; y <= 46; y++) {
                        pixels.push(pixel(x, y, FACE));
                    }
                }

                // === SPATULA ===
                // Handle
                for (let y = 47; y <= 55; y++) {
                    pixels.push(pixel(14, y, SPATULA_HANDLE));
                    pixels.push(pixel(15, y, SPATULA_HANDLE));
                }
                // Metal head
                for (let x = 12; x <= 17; x++) {
                    for (let y = 56; y <= 62; y++) {
                        pixels.push(pixel(x, y, SPATULA_METAL));
                    }
                }

                // === NECK (y: 49-52) ===
                for (let y = 49; y <= 52; y++) {
                    for (let x = -5; x <= 5; x++) {
                        pixels.push(pixel(x, y, FUR));
                    }
                }

                // === BIG ROUND HEAD (y: 53-72) - Sam & Max style ===
                for (let y = 53; y <= 72; y++) {
                    // Head gets wider then narrower (round shape)
                    let headWidth;
                    if (y < 56) headWidth = 6 + (y - 53);
                    else if (y < 65) headWidth = 9;
                    else if (y < 70) headWidth = 9 - (y - 65);
                    else headWidth = 4 - (y - 70);

                    for (let x = -headWidth; x <= headWidth; x++) {
                        // Fur texture
                        const shade = (Math.abs(x) === headWidth) ? FUR_DARK :
                                     ((y + x) % 4 === 0) ? FUR_LIGHT : FUR;
                        pixels.push(pixel(x, y, shade));
                    }
                }

                // === FACE AREA (y: 56-65) ===
                for (let y = 56; y <= 65; y++) {
                    const faceWidth = y < 59 ? 4 : (y < 63 ? 5 : 4);
                    for (let x = -faceWidth; x <= faceWidth; x++) {
                        pixels.push(pixel(x, y, FACE));
                    }
                }

                // === EYES (y: 62-64) - friendly, slightly cartoonish ===
                // Eye whites
                pixels.push(pixel(-3, 63, EYE_WHITE)); pixels.push(pixel(-2, 63, EYE_WHITE));
                pixels.push(pixel(-3, 62, EYE_WHITE)); pixels.push(pixel(-2, 62, EYE_WHITE));
                pixels.push(pixel(2, 63, EYE_WHITE)); pixels.push(pixel(3, 63, EYE_WHITE));
                pixels.push(pixel(2, 62, EYE_WHITE)); pixels.push(pixel(3, 62, EYE_WHITE));
                // Pupils
                pixels.push(pixel(-2, 62, EYES));
                pixels.push(pixel(2, 62, EYES));

                // === NOSE (y: 59-61) - big friendly nose ===
                for (let x = -1; x <= 1; x++) {
                    for (let y = 59; y <= 61; y++) {
                        pixels.push(pixel(x, y, NOSE));
                    }
                }

                // === FRIENDLY SMILE (y: 57-58) ===
                pixels.push(pixel(-3, 58, FUR_DARK));
                pixels.push(pixel(-2, 57, FUR_DARK));
                pixels.push(pixel(-1, 57, FUR_DARK));
                pixels.push(pixel(0, 57, FUR_DARK));
                pixels.push(pixel(1, 57, FUR_DARK));
                pixels.push(pixel(2, 57, FUR_DARK));
                pixels.push(pixel(3, 58, FUR_DARK));

                // === CHEF'S HAT (y: 73-88) ===
                // Hat band
                for (let x = -7; x <= 7; x++) {
                    pixels.push(pixel(x, 73, HAT_SHADE));
                    pixels.push(pixel(x, 74, HAT));
                }
                // Hat puff (tall and puffy)
                for (let y = 75; y <= 88; y++) {
                    const hatWidth = y < 80 ? 7 : (y < 85 ? 8 : 6);
                    for (let x = -hatWidth; x <= hatWidth; x++) {
                        const shade = (Math.abs(x) === hatWidth || y === 88) ? HAT_SHADE : HAT;
                        pixels.push(pixel(x, y, shade));
                    }
                }
                // Hat pleats/folds for texture
                pixels.push(pixel(-3, 82, HAT_SHADE));
                pixels.push(pixel(3, 82, HAT_SHADE));
                pixels.push(pixel(0, 85, HAT_SHADE));

                pixels.forEach(px => this.earlSprite.add(px));
                this.earlSprite.setDepth(5);
            }

            // Edge zones for scene transitions
            createEdgeZones(height) {
                // Left edge zone (exit back to backyard)
                this.leftEdgeZone = this.add.zone(40, height * 0.5, 80, height)
                    .setInteractive()
                    .setOrigin(0.5);

                this.leftEdgeZone.on('pointerover', () => {
                    if (!this.inventoryOpen && !this.verbCoinVisible) {
                        this.edgeHovered = 'left';
                        this.showArrowCursor('left');
                    }
                });

                this.leftEdgeZone.on('pointerout', () => {
                    this.edgeHovered = null;
                    this.hideArrowCursor();
                });

                this.leftEdgeZone.on('pointerdown', (pointer) => {
                    if (this.inventoryOpen) return;

                    // Prevent main input handler from overriding our walk
                    this.clickedUI = true;

                    const currentTime = Date.now();
                    const isDoubleClick = (currentTime - (this.edgeClickTime || 0)) < 300;
                    this.edgeClickTime = currentTime;

                    if (isDoubleClick) {
                        // Immediate transition
                        this.hideArrowCursor();
                        this.transitionToScene('BackyardScene', 'from_neighbor');
                    } else {
                        // Walk to edge then transition
                        this.hideArrowCursor();
                        this.walkToEdgeAndTransition(80, height * 0.80, 'BackyardScene', 'from_neighbor');
                    }
                });
            }

            walkToEdgeAndTransition(targetX, targetY, scene, spawnPoint) {
                this.walkTo(targetX, targetY, () => {
                    this.transitionToScene(scene, spawnPoint);
                }, false);
            }

            // Room-specific action handling
            executeAction(action, hotspot) {
                if (action === 'Use' || action === hotspot.verbLabels?.actionVerb) {
                    this.showDialog(hotspot.useResponse);
                } else if (action === 'Look At' || action === hotspot.verbLabels?.lookVerb) {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Talk To' || action === hotspot.verbLabels?.talkVerb) {
                    if (hotspot.talkResponse === 'START_EARL_CONVERSATION') {
                        const npcData = {
                            name: 'Earl',
                            x: 750,
                            y: this.scale.height * 0.55  // Speech bubble will be positioned 280px above this
                        };
                        const dialogue = this.getEarlDialogue();
                        this.enterConversation(npcData, dialogue);
                    } else {
                        this.showDialog(hotspot.talkResponse);
                    }
                }
            }

            // Room-specific item interactions
            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Grill') {
                    this.showDialog(`I don't think Earl would appreciate me tossing my ${item.name} on his grill.`);
                } else if (hotspot.name === 'Earl') {
                    this.showDialog(`I hand Earl my ${item.name}. He looks at it curiously, then hands it back. "Interesting, but I got burgers to flip."`);
                } else {
                    this.showDialog(`That doesn't work.`);
                }
            }

            update() {
                super.update();

                const time = this.time.now * 0.001;

                // Tiki lights gentle flicker
                if (this.tikiLights) {
                    this.tikiLights.forEach((light, i) => {
                        const flicker = Math.sin(time * 4 + i * 1.3) * 0.15 + Math.sin(time * 9 + i * 0.7) * 0.08;
                        light.intensity = 0.6 + flicker;
                    });
                }

                if (this.tikiBlooms) {
                    this.tikiBlooms.forEach((item, i) => {
                        const flicker = Math.sin(time * 4 + i * 1.3) * 0.1;
                        item.bloom.clear();
                        item.bloom.fillStyle(item.color, 0.15 + flicker * 0.3);
                        item.bloom.fillCircle(item.x, item.y, 12);
                        item.bloom.fillStyle(item.color, 0.25 + flicker * 0.2);
                        item.bloom.fillCircle(item.x, item.y, 6);
                    });
                }

                // Grill light flicker
                if (this.grillLight) {
                    const grillFlicker = Math.sin(time * 6) * 0.15 + Math.sin(time * 11) * 0.1;
                    this.grillLight.intensity = 0.9 + grillFlicker;
                }

                // Animate smoke particles
                if (this.smokeParticles) {
                    this.smokeParticles.forEach((particle, i) => {
                        // Rise and drift
                        const yOffset = (time * particle.speed * 50 + particle.offset * 100) % 150;
                        const xDrift = Math.sin(time * 2 + particle.offset) * 15;

                        particle.graphic.setPosition(
                            particle.baseX + xDrift,
                            particle.baseY - yOffset
                        );

                        // Fade as it rises
                        const alpha = Math.max(0, 0.4 - (yOffset / 300));
                        particle.graphic.setAlpha(alpha);
                    });
                }
            }
        }

        // ============================================================================
        // ATTIC SCENE - Teenager's bedroom with alien resident
        // ============================================================================
        class AtticScene extends BaseScene {
            constructor() {
                super({ key: 'AtticScene' });
                this.worldWidth = 1280; // Single screen, no scrolling
                this.screenWidth = 1280;
                this.walkableArea = { minY: 0.70, maxY: 0.92 };
                this.alienSprite = null;
                this.tvFlickerTime = 0;
            }

            getHotspotData(height) {
                return [
                    {
                        x: 100, y: height * 0.55, w: 120, h: height * 0.35,
                        interactX: 180, interactY: height * 0.78,
                        name: 'Stairs Down',
                        verbLabels: { actionVerb: 'Descend', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "The stairs leading back down to the house. The warm glow from below is inviting.",
                        useResponse: "TRANSITION_TO_HOUSE",
                        talkResponse: "Thanks for the workout, stairs. My calves appreciate it."
                    },
                    {
                        x: 640, y: height * 0.48, w: 180, h: height * 0.30,
                        interactX: 520, interactY: height * 0.78,
                        name: 'Alien',
                        isNPC: true,
                        verbLabels: { actionVerb: 'Poke', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A gray alien. Huge black eyes, oversized head, sitting on a ratty couch... watching what appears to be a soap opera. This is not what I expected to find in an attic.",
                        useResponse: "He swats my hand away without looking. 'Do you MIND? Elena is about to confront Ricardo about the baby.'",
                        talkResponse: "START_ALIEN_CONVERSATION"
                    },
                    {
                        x: 640, y: height * 0.85, w: 250, h: height * 0.12,
                        interactX: 640, interactY: height * 0.82,
                        name: 'Old Couch',
                        verbLabels: { actionVerb: 'Sit on', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A beat-up old couch that's seen better decades. Currently occupied by an extraterrestrial being. The cushions are worn to the shape of someone who's been sitting there for... years?",
                        useResponse: "I start to sit down. The alien shifts over slightly, eyes still glued to the screen. I'll take that as an invitation.",
                        talkResponse: "The couch creaks ominously. It's been through a lot."
                    },
                    {
                        x: 1100, y: height * 0.55, w: 120, h: height * 0.25,
                        interactX: 1020, interactY: height * 0.78,
                        name: 'TV',
                        verbLabels: { actionVerb: 'Change channel', lookVerb: 'Watch', talkVerb: 'Talk to' },
                        lookResponse: "An ancient CRT television. The screen shows what looks like a telenovela - lots of dramatic close-ups and passionate arguing. The alien seems riveted.",
                        useResponse: "I reach for the dial. 'Touch that and I will END you,' the alien says flatly, still not looking away.",
                        talkResponse: "The TV responds with melodramatic Spanish dialogue. Someone named Ricardo has apparently betrayed someone."
                    },
                    {
                        x: 280, y: height * 0.35, w: 100, h: height * 0.25,
                        interactX: 300, interactY: height * 0.78,
                        name: 'Guitar',
                        verbLabels: { actionVerb: 'Play', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A dusty electric guitar leaning in the corner. Hasn't been played in a while. The strings are coated in what I hope is just dust.",
                        useResponse: "I strum it gently. The alien winces. 'That belonged to the teenager who lived here. Please stop. You're worse than he was.'",
                        talkResponse: "Sing me a song, guitar. No? Fair enough."
                    },
                    {
                        x: 400, y: height * 0.18, w: 200, h: height * 0.20,
                        interactX: 450, interactY: height * 0.78,
                        name: 'Band Posters',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Faded band posters on the sloped ceiling. Some 80s hair metal, some grunge. Whoever lived here had eclectic taste. And possibly hearing damage.",
                        useResponse: "The posters are practically glued to the wall by decades of humidity. They're not going anywhere.",
                        talkResponse: "The bands on these posters are probably all broken up by now. Such is the nature of rock and roll."
                    },
                    {
                        x: 900, y: height * 0.25, w: 80, h: height * 0.18,
                        interactX: 850, interactY: height * 0.78,
                        name: 'Strange Device',
                        verbLabels: { actionVerb: 'Touch', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "Some kind of alien technology? It's got blinking lights and smooth curves that definitely weren't made on Earth. Looks broken though - there's a crack running through the middle.",
                        useResponse: "I touch it gingerly. Nothing happens. 'It's dead,' the alien says without looking. 'Like my hopes of ever leaving this planet.'",
                        talkResponse: "The device hums softly but doesn't respond. Typical."
                    },
                    {
                        x: 1150, y: height * 0.75, w: 80, h: height * 0.15,
                        interactX: 1080, interactY: height * 0.80,
                        name: 'Snack Pile',
                        verbLabels: { actionVerb: 'Search', lookVerb: 'Examine', talkVerb: 'Talk to' },
                        lookResponse: "A mountain of empty chip bags, candy wrappers, and soda cans. The alien has apparently developed a taste for Earth junk food. The pile is... impressive.",
                        useResponse: "I dig through the wrappers. Nothing but crumbs and regret. 'Those are MINE,' the alien mutters.",
                        talkResponse: "The snack pile rustles slightly. I hope that's just settling."
                    }
                ];
            }

            // Alien dialogue tree - cranky, obsessed with TV, secretly lonely
            getAlienDialogue() {
                return {
                    start: {
                        npcGreeting: this.getFlag('alien_talked_before')
                            ? "You again. Can't you see I'm busy? Elena just found out Ricardo is actually her half-brother."
                            : "*sigh* A human. In MY attic. The doctor said you might come up here eventually. What do you want?",
                        options: [
                            {
                                text: "What are you?",
                                heroLine: "So... not to be rude, but... what exactly ARE you?",
                                npcResponse: "What am I? WHAT AM I? I am Zyx'thorian the Destroyer, Harbinger of Extinction, He Who Brings the Final Night! ...Currently on hiatus. Shh, commercial's over.",
                                setFlag: 'alien_asked_what',
                                condition: (scene) => !scene.getFlag('alien_asked_what')
                            },
                            {
                                text: "Why are you watching TV?",
                                heroLine: "So... an alien. Watching soap operas. In an attic. This is normal.",
                                npcResponse: "These humans are IDIOTS. They lie, they betray, they make the worst possible decisions at every turn. It's... *chef's kiss* ...exquisite. I've learned more about human psychology from 'Passion's Tempest' than from any probe.",
                                setFlag: 'alien_asked_tv',
                                nextNode: 'tv_discussion',
                                condition: (scene) => !scene.getFlag('alien_asked_tv')
                            },
                            {
                                text: "How long have you been here?",
                                heroLine: "How long have you been up here exactly?",
                                npcResponse: "By your Earth calendar? Approximately... seventeen years. My ship crashed in 2009. I was SUPPOSED to trigger the extinction event, but the impact damaged my transmitter. And then I discovered basic cable.",
                                setFlag: 'alien_asked_how_long',
                                nextNode: 'crashed_ship'
                            },
                            {
                                text: "Tell me about your ship.",
                                heroLine: "You mentioned your ship crashed?",
                                npcResponse: "Yes, my magnificent vessel is now scattered across the neighboring forest. The self-destruct didn't even work properly. Everything is broken. Like my dreams.",
                                setFlag: 'alien_asked_ship',
                                nextNode: 'crashed_ship',
                                condition: (scene) => scene.getFlag('alien_asked_how_long') && !scene.getFlag('alien_asked_ship')
                            },
                            {
                                text: "I'll let you get back to your show.",
                                heroLine: "I'll leave you to your... program.",
                                npcResponse: "Finally, some consideration. Come back during commercials if you must talk. And close the door - you're letting the glow out.",
                                exit: true,
                                setFlag: 'alien_talked_before'
                            }
                        ]
                    },
                    tv_discussion: {
                        options: [
                            {
                                text: "What's happening in the show?",
                                heroLine: "So what's the plot of this thing?",
                                npcResponse: "WHERE DO I BEGIN. Elena married Ricardo not knowing he killed her father, but her father was actually alive and plotting revenge with Ricardo's evil twin, and NOW it turns out Ricardo might be her half-brother through a secret affair and- oh, you don't care. Nobody cares about MY interests.",
                                setFlag: 'alien_explained_plot'
                            },
                            {
                                text: "Seems like trash TV.",
                                heroLine: "I mean... this seems like pretty terrible television.",
                                npcResponse: "*bristles* TERRIBLE? This is ART. The melodrama, the betrayal, the inexplicable amnesia subplots... Your species creates garbage, but OCCASIONALLY that garbage is transcendent. Now be quiet, the evil twin is about to reveal himself.",
                                setFlag: 'alien_defended_show'
                            },
                            {
                                text: "Back to other topics.",
                                heroLine: "Let's talk about something else.",
                                npcResponse: "If we must.",
                                nextNode: 'start'
                            }
                        ]
                    },
                    crashed_ship: {
                        options: [
                            {
                                text: "Why don't you fix it?",
                                heroLine: "Can't you repair your ship and leave?",
                                npcResponse: "Oh, BRILLIANT suggestion. Fix the QUANTUM DISPLACEMENT DRIVE with EARTH TECHNOLOGY. Why didn't I think of that? The most advanced device your species has invented is the combination pizza oven and also it's a phone. I'm STUCK here.",
                                setFlag: 'alien_asked_repair'
                            },
                            {
                                text: "What about destroying Earth?",
                                heroLine: "Weren't you supposed to destroy Earth or something?",
                                npcResponse: "Yes, yes, extinction event, cosmic mandate, heat death of your sun hastened by three billion years, very important. But I MISSED the window. And then I discovered snacks. Have you tried 'Cool Ranch'? It's not cool and it's not ranch, but it IS delicious.",
                                setFlag: 'alien_asked_destroy',
                                condition: (scene) => !scene.getFlag('alien_asked_destroy')
                            },
                            {
                                text: "Do you miss home?",
                                heroLine: "Do you ever miss... wherever you're from?",
                                npcResponse: "...Sometimes. At night, when the TV is off and the house is quiet. My homeworld had seven moons. The light was always silver. Here it's just... dark. And your moon is PATHETIC. One? ONE moon? How do you even have tides?",
                                setFlag: 'alien_asked_home',
                                condition: (scene) => !scene.getFlag('alien_asked_home')
                            },
                            {
                                text: "Let's talk about something else.",
                                heroLine: "Let's change the subject.",
                                npcResponse: "Fine by me. The commercial break is almost over anyway.",
                                nextNode: 'start'
                            }
                        ]
                    }
                };
            }

            create() {
                const { width, height } = this.scale;

                // Camera setup - no scrolling for single screen
                this.cameras.main.setBounds(0, 0, this.worldWidth, height);

                // Enable lighting - bright ambient similar to main house
                this.lights.enable();
                const isMobile = this.sys.game.device.input.touch;
                this.lights.setAmbientColor(isMobile ? 0x9a9aaa : 0x7a7a8a); // Brighter on mobile

                // Draw room background
                this.drawRoom(this.worldWidth, height);

                // Create lighting
                this.createLighting(this.worldWidth, height);

                // Call parent create (sets up all UI systems)
                super.create();

                // Create hotspots
                this.createHotspots(this.getHotspotData(height));

                // Create alien sprite
                this.createAlien(height);

                // Create player at spawn position
                const spawnPoint = this.registry.get('spawnPoint') || 'default';
                let spawnX = 180;
                if (spawnPoint === 'from_house') spawnX = 180;

                this.createPlayer(spawnX, height * 0.82);

                // Mark room as visited
                const state = this.getGameState();
                if (!state.visitedRooms.includes('attic')) {
                    state.visitedRooms.push('attic');
                    this.setGameState(state);
                    // First time entering - alien speaks
                    this.time.delayedCall(500, () => {
                        this.showDialog("*muttering from the darkness* Oh great. ANOTHER visitor. As if I didn't have enough interruptions.");
                    });
                }
            }

            // Draw attic room - MI2/Day of Tentacle style with TV glow
            drawRoom(worldWidth, height) {
                if (this.textures.exists('roomBackground')) {
                    this.textures.remove('roomBackground');
                }

                const roomTexture = this.add.renderTexture(0, 0, worldWidth, height);
                const g = this.make.graphics({ add: false });

                // Color palette - dark and moody with blue TV tones
                const WALL_DARK = 0x0a0a12;
                const WALL_MID = 0x12121a;
                const WALL_LIGHT = 0x1a1a25;
                const WOOD_DARK = 0x1a1208;
                const WOOD_MID = 0x2a2010;
                const WOOD_LIGHT = 0x3a3018;
                const FLOOR_DARK = 0x1a1510;
                const FLOOR_MID = 0x2a2518;
                const TV_GLOW = 0x4488cc;
                const TV_GLOW_LIGHT = 0x66aaee;

                const floorY = height * 0.70;

                // === BACK WALL (sloped attic ceiling) ===
                g.fillStyle(WALL_DARK);
                g.fillRect(0, 0, worldWidth, height);

                // Sloped ceiling from left
                g.fillStyle(WALL_MID);
                g.beginPath();
                g.moveTo(0, height * 0.10);
                g.lineTo(400, height * 0.05);
                g.lineTo(400, floorY);
                g.lineTo(0, floorY);
                g.closePath();
                g.fillPath();

                // Sloped ceiling from right
                g.beginPath();
                g.moveTo(worldWidth, height * 0.10);
                g.lineTo(880, height * 0.05);
                g.lineTo(880, floorY);
                g.lineTo(worldWidth, floorY);
                g.closePath();
                g.fillPath();

                // Center flat ceiling area
                g.fillStyle(WALL_LIGHT);
                g.fillRect(400, 0, 480, height * 0.08);

                // Ceiling beams (exposed rafters)
                g.fillStyle(WOOD_DARK);
                for (let i = 0; i < 5; i++) {
                    const beamX = 200 + i * 220;
                    // Angled beams following roof slope
                    g.lineStyle(8, WOOD_MID, 1);
                    if (beamX < 400) {
                        g.moveTo(beamX, height * 0.10 - (beamX / 400) * height * 0.05);
                        g.lineTo(beamX, floorY);
                    } else if (beamX > 880) {
                        g.moveTo(beamX, height * 0.10 - ((worldWidth - beamX) / 400) * height * 0.05);
                        g.lineTo(beamX, floorY);
                    } else {
                        g.moveTo(beamX, height * 0.05);
                        g.lineTo(beamX, floorY);
                    }
                    g.strokePath();
                }

                // === TV GLOW on walls (dithered) ===
                for (let px = 800; px < worldWidth; px += 4) {
                    for (let py = 50; py < floorY; py += 4) {
                        const dist = Math.sqrt(Math.pow(px - 1100, 2) + Math.pow(py - height * 0.50, 2));
                        if (dist < 350 && (px + py) % 8 === 0) {
                            const intensity = 1 - (dist / 350);
                            if (intensity > 0.3) {
                                g.fillStyle(TV_GLOW);
                                g.fillRect(px, py, 3, 3);
                            } else if (intensity > 0.1) {
                                g.fillStyle(0x223344);
                                g.fillRect(px, py, 2, 2);
                            }
                        }
                    }
                }

                // === FLOOR (old wooden boards) ===
                g.fillStyle(FLOOR_DARK);
                g.fillRect(0, floorY, worldWidth, height - floorY);

                // Floorboard lines
                g.lineStyle(2, WOOD_DARK, 0.7);
                for (let x = 0; x < worldWidth; x += 70) {
                    g.moveTo(x, floorY);
                    g.lineTo(x, height);
                    g.strokePath();
                }

                // Floor dithering
                for (let px = 0; px < worldWidth; px += 6) {
                    for (let py = floorY; py < height; py += 6) {
                        if ((px + py) % 18 === 0) {
                            g.fillStyle(FLOOR_MID);
                            g.fillRect(px, py, 3, 2);
                        }
                    }
                }

                // === STAIRS (left side, going down) ===
                const stairX = 50, stairY = floorY - 30;
                // Stairwell opening
                g.fillStyle(0x2a1a0a);
                g.fillRect(stairX, stairY - 20, 130, floorY - stairY + 50);
                // Warm glow from below
                g.fillStyle(0x3a2a15);
                g.fillRect(stairX + 10, stairY, 110, 40);
                for (let i = 0; i < 4; i++) {
                    g.fillStyle(0x2a1a08);
                    g.fillRect(stairX + 20, stairY + 35 + i * 15, 90, 8);
                }
                // Railing
                g.fillStyle(WOOD_MID);
                g.fillRect(stairX + 120, stairY - 50, 8, 80);
                g.fillStyle(WOOD_LIGHT);
                g.fillCircle(stairX + 124, stairY - 55, 8);

                // === BAND POSTERS on sloped walls ===
                // Left wall poster 1
                g.fillStyle(0x4a2020);
                g.fillRect(250, 90, 80, 100);
                g.fillStyle(0x6a3030);
                g.fillRect(255, 95, 70, 70);
                // Skull graphic (simplified)
                g.fillStyle(0xd0d0d0);
                g.fillCircle(290, 125, 18);
                g.fillStyle(0x4a2020);
                g.fillCircle(283, 120, 5);
                g.fillCircle(297, 120, 5);
                g.fillRect(280, 132, 20, 8);
                // Band name text
                g.fillStyle(0xff4444);
                g.fillRect(258, 168, 64, 8);

                // Left wall poster 2
                g.fillStyle(0x203050);
                g.fillRect(350, 70, 70, 90);
                g.fillStyle(0x3050a0);
                g.fillRect(355, 75, 60, 60);
                // Lightning bolt
                g.fillStyle(0xffff00);
                g.beginPath();
                g.moveTo(385, 80);
                g.lineTo(375, 105);
                g.lineTo(385, 105);
                g.lineTo(375, 130);
                g.lineTo(395, 100);
                g.lineTo(385, 100);
                g.closePath();
                g.fillPath();

                // === GUITAR in corner ===
                const guitarX = 230, guitarY = floorY - 20;
                // Guitar body
                g.fillStyle(0x6a2020);
                g.fillCircle(guitarX, guitarY - 40, 35);
                g.fillCircle(guitarX, guitarY - 90, 28);
                // Guitar neck
                g.fillStyle(WOOD_MID);
                g.fillRect(guitarX - 6, guitarY - 200, 12, 130);
                // Headstock
                g.fillStyle(WOOD_DARK);
                g.fillRect(guitarX - 10, guitarY - 220, 20, 25);
                // Strings (subtle)
                g.lineStyle(1, 0xaaaaaa, 0.5);
                for (let s = 0; s < 6; s++) {
                    g.moveTo(guitarX - 4 + s * 1.5, guitarY - 195);
                    g.lineTo(guitarX - 4 + s * 1.5, guitarY - 50);
                }
                g.strokePath();

                // === COUCH (center, worn out) ===
                const couchX = 500, couchY = floorY - 20, couchW = 280, couchH = 100;
                // Couch frame
                g.fillStyle(0x3a2a20);
                g.fillRect(couchX, couchY - couchH, couchW, couchH);
                // Cushions (lumpy, worn)
                g.fillStyle(0x4a3525);
                g.fillRect(couchX + 10, couchY - couchH + 15, couchW - 20, couchH - 30);
                // Cushion lines
                g.fillStyle(0x3a2518);
                g.fillRect(couchX + couchW/3, couchY - couchH + 15, 4, couchH - 35);
                g.fillRect(couchX + couchW*2/3, couchY - couchH + 15, 4, couchH - 35);
                // Back cushions
                g.fillStyle(0x4a3020);
                g.fillRect(couchX + 15, couchY - couchH - 40, couchW - 30, 45);
                // Couch arms
                g.fillStyle(0x3a2520);
                g.fillRect(couchX - 20, couchY - couchH - 20, 35, couchH + 20);
                g.fillRect(couchX + couchW - 15, couchY - couchH - 20, 35, couchH + 20);
                // TV glow on couch
                for (let cx = couchX; cx < couchX + couchW; cx += 5) {
                    for (let cy = couchY - couchH; cy < couchY; cy += 5) {
                        if ((cx + cy) % 15 === 0) {
                            g.fillStyle(TV_GLOW);
                            g.fillRect(cx, cy, 2, 2);
                        }
                    }
                }

                // === TV (foreground, seen from behind - silhouette) ===
                const tvX = 1020, tvY = floorY - 30, tvW = 180, tvH = 150;
                // TV back (dark silhouette)
                g.fillStyle(0x0a0a0a);
                g.fillRect(tvX, tvY - tvH, tvW, tvH);
                // TV shape details
                g.fillStyle(0x151515);
                g.fillRect(tvX + 10, tvY - tvH + 10, tvW - 20, tvH - 30);
                // Vents on back
                for (let v = 0; v < 5; v++) {
                    g.fillStyle(0x050505);
                    g.fillRect(tvX + 30, tvY - tvH + 25 + v * 20, tvW - 60, 8);
                }
                // TV stand
                g.fillStyle(0x0a0a0a);
                g.fillRect(tvX + 40, tvY - 5, tvW - 80, 10);
                g.fillRect(tvX + 60, tvY, tvW - 120, 30);
                // Glow spilling around edges
                g.fillStyle(TV_GLOW_LIGHT);
                g.fillRect(tvX - 5, tvY - tvH, 5, tvH);
                g.fillRect(tvX + tvW, tvY - tvH, 5, tvH);
                g.fillRect(tvX, tvY - tvH - 5, tvW, 5);

                // === ALIEN ARTIFACT (broken device) ===
                const artifactX = 880, artifactY = 140;
                // Base
                g.fillStyle(0x3a3a4a);
                g.fillCircle(artifactX, artifactY, 30);
                g.fillStyle(0x2a2a3a);
                g.fillCircle(artifactX, artifactY, 22);
                // Blinking lights
                g.fillStyle(0x00ff00);
                g.fillCircle(artifactX - 10, artifactY - 5, 3);
                g.fillStyle(0xff0000);
                g.fillCircle(artifactX + 10, artifactY - 5, 3);
                g.fillStyle(0x0066ff);
                g.fillCircle(artifactX, artifactY + 8, 3);
                // Crack
                g.lineStyle(2, 0x1a1a2a, 1);
                g.moveTo(artifactX - 15, artifactY - 20);
                g.lineTo(artifactX + 5, artifactY + 5);
                g.lineTo(artifactX + 20, artifactY + 25);
                g.strokePath();

                // === SNACK PILE (right side) ===
                const snackX = 1130, snackY = floorY - 10;
                // Pile of wrappers
                const wrapperColors = [0xdd2222, 0x22dd22, 0xdddd22, 0x2222dd, 0xdd8822];
                for (let w = 0; w < 15; w++) {
                    g.fillStyle(wrapperColors[w % wrapperColors.length]);
                    const wx = snackX + (w % 5) * 15 - 30 + Math.sin(w) * 10;
                    const wy = snackY - Math.floor(w / 5) * 12 - 10;
                    g.fillRect(wx, wy, 12 + (w % 3) * 4, 8 + (w % 2) * 4);
                }
                // Soda cans
                g.fillStyle(0xcc0000);
                g.fillRect(snackX + 30, snackY - 35, 18, 28);
                g.fillStyle(0xaaaaaa);
                g.fillRect(snackX + 30, snackY - 35, 18, 5);
                g.fillStyle(0x0000cc);
                g.fillRect(snackX - 10, snackY - 45, 18, 28);
                g.fillStyle(0xaaaaaa);
                g.fillRect(snackX - 10, snackY - 45, 18, 5);

                // === MISCELLANEOUS CLUTTER ===
                // Old magazines
                g.fillStyle(0x8a7a60);
                g.fillRect(450, floorY + 30, 40, 5);
                g.fillRect(455, floorY + 25, 40, 5);
                g.fillRect(448, floorY + 35, 40, 5);

                // Dust particles (dithered atmosphere)
                for (let px = 0; px < worldWidth; px += 20) {
                    for (let py = 50; py < floorY; py += 25) {
                        if ((px * py) % 500 < 5) {
                            g.fillStyle(0x333340);
                            g.fillRect(px, py, 1, 1);
                        }
                    }
                }

                roomTexture.draw(g);
                g.destroy();

                roomTexture.saveTexture('roomBackground');
                roomTexture.destroy();

                this.roomSprite = this.add.sprite(0, 0, 'roomBackground');
                this.roomSprite.setOrigin(0, 0);
                this.roomSprite.setPipeline('Light2D');
                this.roomSprite.setDepth(0);
            }

            // Create alien sprite
            createAlien(height) {
                this.alienSprite = this.add.container(640, height * 0.52);

                const p = 3; // Pixel size

                // Color palette
                const SKIN_DARK = 0x5a5a6a;
                const SKIN_MID = 0x7a7a8a;
                const SKIN_LIGHT = 0x9a9aaa;
                const EYE_BLACK = 0x000000;
                const EYE_SHINE = 0x2a2a4a;
                const TEETH = 0xcccccc;

                const createPixel = (x, y, color) => {
                    const pixel = this.add.graphics();
                    pixel.fillStyle(color, 1);
                    pixel.fillRect(x * p, y * p, p, p);
                    pixel.setPipeline('Light2D');
                    return pixel;
                };

                // Body (sitting, hunched forward watching TV)
                // Torso
                for (let x = -8; x <= 8; x++) {
                    for (let y = 10; y <= 30; y++) {
                        if (Math.abs(x) <= 6 + (y - 10) * 0.2) {
                            const color = x < -3 ? SKIN_DARK : x > 3 ? SKIN_DARK : SKIN_MID;
                            this.alienSprite.add(createPixel(x, y, color));
                        }
                    }
                }

                // Arms (thin, resting on knees)
                // Left arm
                for (let i = 0; i < 15; i++) {
                    this.alienSprite.add(createPixel(-9 - i * 0.3, 15 + i * 0.8, SKIN_MID));
                    this.alienSprite.add(createPixel(-10 - i * 0.3, 15 + i * 0.8, SKIN_DARK));
                }
                // Right arm
                for (let i = 0; i < 15; i++) {
                    this.alienSprite.add(createPixel(9 + i * 0.3, 15 + i * 0.8, SKIN_MID));
                    this.alienSprite.add(createPixel(10 + i * 0.3, 15 + i * 0.8, SKIN_DARK));
                }

                // Hands (three long fingers each)
                for (let f = 0; f < 3; f++) {
                    // Left hand fingers
                    this.alienSprite.add(createPixel(-14 + f * 2, 28, SKIN_LIGHT));
                    this.alienSprite.add(createPixel(-14 + f * 2, 29, SKIN_MID));
                    // Right hand fingers
                    this.alienSprite.add(createPixel(14 + f * 2, 28, SKIN_LIGHT));
                    this.alienSprite.add(createPixel(14 + f * 2, 29, SKIN_MID));
                }

                // Neck (thin)
                for (let y = 5; y <= 10; y++) {
                    this.alienSprite.add(createPixel(-2, y, SKIN_DARK));
                    this.alienSprite.add(createPixel(-1, y, SKIN_MID));
                    this.alienSprite.add(createPixel(0, y, SKIN_MID));
                    this.alienSprite.add(createPixel(1, y, SKIN_MID));
                    this.alienSprite.add(createPixel(2, y, SKIN_DARK));
                }

                // Head (oversized, classic gray alien shape)
                for (let y = -25; y <= 5; y++) {
                    const headWidth = Math.floor(12 - Math.abs(y + 10) * 0.4);
                    for (let x = -headWidth; x <= headWidth; x++) {
                        let color = SKIN_MID;
                        if (x < -headWidth + 3) color = SKIN_DARK;
                        else if (x > headWidth - 3) color = SKIN_DARK;
                        else if (y < -20) color = SKIN_LIGHT;
                        this.alienSprite.add(createPixel(x, y, color));
                    }
                }

                // Eyes (huge, black, almond-shaped, reflecting TV)
                // Left eye
                for (let y = -15; y <= -5; y++) {
                    const eyeWidth = Math.floor(5 - Math.abs(y + 10) * 0.4);
                    for (let x = -10; x <= -10 + eyeWidth * 2; x++) {
                        this.alienSprite.add(createPixel(x, y, EYE_BLACK));
                    }
                }
                // Right eye
                for (let y = -15; y <= -5; y++) {
                    const eyeWidth = Math.floor(5 - Math.abs(y + 10) * 0.4);
                    for (let x = 10 - eyeWidth * 2; x <= 10; x++) {
                        this.alienSprite.add(createPixel(x, y, EYE_BLACK));
                    }
                }
                // Eye shine (TV reflection)
                this.alienSprite.add(createPixel(-8, -12, EYE_SHINE));
                this.alienSprite.add(createPixel(-7, -11, 0x4488aa));
                this.alienSprite.add(createPixel(6, -12, EYE_SHINE));
                this.alienSprite.add(createPixel(7, -11, 0x4488aa));

                // Mouth (thin line with hints of sharp teeth)
                for (let x = -4; x <= 4; x++) {
                    this.alienSprite.add(createPixel(x, 0, SKIN_DARK));
                }
                // Sharp teeth peeking
                this.alienSprite.add(createPixel(-3, 1, TEETH));
                this.alienSprite.add(createPixel(-1, 1, TEETH));
                this.alienSprite.add(createPixel(1, 1, TEETH));
                this.alienSprite.add(createPixel(3, 1, TEETH));
                // Teeth points
                this.alienSprite.add(createPixel(-2, 2, TEETH));
                this.alienSprite.add(createPixel(0, 2, TEETH));
                this.alienSprite.add(createPixel(2, 2, TEETH));

                this.alienSprite.setDepth(50);
            }

            createLighting(worldWidth, height) {
                // Primary light: TV glow (flickering blue-white) - increased intensity
                this.tvLight = this.lights.addLight(1100, height * 0.45, 500, 0x6699cc, 2.5);
                this.tvGlow = this.lights.addLight(1100, height * 0.50, 300, 0x88bbee, 2.0);

                // Secondary: warm glow from stairwell
                this.stairLight = this.lights.addLight(120, height * 0.65, 200, 0xffaa66, 0.8);

                // Fill light - brighter so we can see the room
                this.fillLight = this.lights.addLight(640, height * 0.50, 600, 0x445566, 0.4);

                // Artifact blinking light
                this.artifactLight = this.lights.addLight(880, 140, 80, 0x00ff00, 0.4);

                // TV bloom effects (behind the TV silhouette)
                this.tvBloom1 = this.add.graphics();
                this.tvBloom1.fillStyle(0x4488cc, 0.2);
                this.tvBloom1.fillCircle(0, 0, 120);
                this.tvBloom1.setPosition(1100, height * 0.45);
                this.tvBloom1.setBlendMode(Phaser.BlendModes.ADD);
                this.tvBloom1.setDepth(1);

                this.tvBloom2 = this.add.graphics();
                this.tvBloom2.fillStyle(0x6699aa, 0.12);
                this.tvBloom2.fillCircle(0, 0, 220);
                this.tvBloom2.setPosition(1100, height * 0.45);
                this.tvBloom2.setBlendMode(Phaser.BlendModes.ADD);
                this.tvBloom2.setDepth(1);

                // TV silhouette (drawn in FRONT of the bloom effects)
                const floorY = height * 0.70;
                const tvX = 1020, tvY = floorY - 30, tvW = 180, tvH = 150;
                this.tvSilhouette = this.add.graphics();
                // TV back (dark silhouette)
                this.tvSilhouette.fillStyle(0x0a0a0a);
                this.tvSilhouette.fillRect(tvX, tvY - tvH, tvW, tvH);
                // TV shape details
                this.tvSilhouette.fillStyle(0x151515);
                this.tvSilhouette.fillRect(tvX + 10, tvY - tvH + 10, tvW - 20, tvH - 30);
                // Vents on back
                for (let v = 0; v < 5; v++) {
                    this.tvSilhouette.fillStyle(0x050505);
                    this.tvSilhouette.fillRect(tvX + 30, tvY - tvH + 25 + v * 20, tvW - 60, 8);
                }
                // TV stand
                this.tvSilhouette.fillStyle(0x0a0a0a);
                this.tvSilhouette.fillRect(tvX + 40, tvY - 5, tvW - 80, 10);
                this.tvSilhouette.fillRect(tvX + 60, tvY, tvW - 120, 30);
                // Glow spilling around edges (visible from behind)
                this.tvSilhouette.fillStyle(0x66aaee);
                this.tvSilhouette.fillRect(tvX - 5, tvY - tvH, 5, tvH);
                this.tvSilhouette.fillRect(tvX + tvW, tvY - tvH, 5, tvH);
                this.tvSilhouette.fillRect(tvX, tvY - tvH - 5, tvW, 5);
                this.tvSilhouette.setDepth(2); // In front of bloom effects
            }

            executeAction(action, hotspot) {
                if (action === 'Use' || action === hotspot.verbLabels?.actionVerb) {
                    if (hotspot.name === 'Stairs Down') {
                        this.transitionToScene('GameScene', 'from_attic');
                    } else {
                        this.showDialog(hotspot.useResponse);
                    }
                } else if (action === 'Look At' || action === hotspot.verbLabels?.lookVerb) {
                    this.showDialog(hotspot.lookResponse);
                } else if (action === 'Talk To' || action === hotspot.verbLabels?.talkVerb) {
                    if (hotspot.talkResponse === 'START_ALIEN_CONVERSATION') {
                        const npcData = {
                            name: 'Zyx',
                            x: 640,
                            y: this.scale.height * 0.55
                        };
                        const dialogue = this.getAlienDialogue();
                        this.enterConversation(npcData, dialogue);
                    } else {
                        this.showDialog(hotspot.talkResponse);
                    }
                }
            }

            useItemOnHotspot(item, hotspot) {
                if (hotspot.name === 'Alien') {
                    this.showDialog(`The alien glances at my ${item.name}. 'Fascinating. Truly. Now put it away, you're blocking the screen.'`);
                } else if (hotspot.name === 'TV') {
                    this.showDialog(`I'm not putting my ${item.name} anywhere near that TV. The alien might actually destroy me.`);
                } else if (hotspot.name === 'Snack Pile') {
                    this.showDialog(`I add my ${item.name} to the pile. It fits right in with the rest of the garbage.`);
                } else {
                    this.showDialog(`That doesn't work.`);
                }
            }

            update() {
                super.update();

                const { height } = this.scale;
                const time = this.time.now * 0.001;

                // TV flicker effect
                if (this.tvLight) {
                    const flicker = 1 + Math.sin(time * 8) * 0.1 + Math.sin(time * 13) * 0.05 + Math.random() * 0.05;
                    this.tvLight.setIntensity(1.8 * flicker);
                    this.tvGlow.setIntensity(1.2 * flicker);

                    // Occasional color shift (scene change on TV)
                    if (Math.random() < 0.002) {
                        const colors = [0x6699cc, 0x99cc66, 0xcc9966, 0x9966cc];
                        const newColor = colors[Math.floor(Math.random() * colors.length)];
                        this.tvLight.setColor(newColor);
                    }
                }

                // Artifact light blink
                if (this.artifactLight) {
                    const blink = Math.sin(time * 2) > 0.7 ? 0.4 : 0.1;
                    this.artifactLight.setIntensity(blink);
                    // Occasionally change color
                    if (Math.sin(time * 0.5) > 0.9) {
                        this.artifactLight.setColor(0xff0000);
                    } else if (Math.sin(time * 0.5) < -0.9) {
                        this.artifactLight.setColor(0x0066ff);
                    } else {
                        this.artifactLight.setColor(0x00ff00);
                    }
                }

                // TV bloom pulse
                if (this.tvBloom1) {
                    const pulse = 1 + Math.sin(time * 6) * 0.15;
                    this.tvBloom1.setScale(pulse);
                }
            }
        }

        // ============================================================================
        // GAME CONFIG
        // ============================================================================
        const config = {
            type: Phaser.WEBGL,
            parent: 'game-container',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1280,
                height: 720
            },
            backgroundColor: '#1a1a2e',
            scene: [GameScene, GardenScene, ForestScene, LaboratoryScene, BackyardScene, NeighborYardScene, AtticScene],
            input: { activePointers: 1 }
        };

        // Wait for the custom font to load before starting the game
        document.fonts.load('16px "Press Start 2P"').then(() => {
            new Phaser.Game(config);
        });
    </script>
</body>
</html>
